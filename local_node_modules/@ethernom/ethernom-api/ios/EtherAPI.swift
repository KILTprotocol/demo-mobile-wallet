//
//  EtherAPI.swift
//  ethernom-api
//
//  Created by admin on 20/10/2019.
//  Copyright Â© 2019 admin. All rights reserved.
//

import Foundation
let  ETH_STRING_AS_UNICODE = 0x01;
let	 ETH_STRING_AS_HEX	   = 0x02;
let  ETH_STRING_AS_ASUTF8  = 0x03;
let  ETH_INT_AS_BYTE	   = 0x04;
let  ETH_INT_AS_2BYTE	   = 0x05;
let  ETH_INT_AS_4BYTE	   = 0x06;
let  ETH_AS_ARRAY		   = 0x07;

let ETH_UNICODESTRING = 0x11;
let ETH_UTF8STRING	  = 0x12;
let ETH_BYTE		  = 0x13;
let ETH_2BYTE		  = 0x14;
let ETH_PAYLOAD		  = 0x15;
let ETH_4BYTE		  = 0x16;

@objcMembers class EtherAPI: NSObject, DiscoverServiceListener, CardListener, AdapterListener, ConnectionListener, EncConnectionListener {
  
  var _adapter: EtherCommAdapter?
  var transport: EtherTransportProtocol = EtherTransportProtocol(servicePort: 0, interfaceKind: .BLE, messageProtocol: .APP)
  var openServiceCmd: UInt8 = UInt8(bitPattern: Int8(-1))
  var instanceID : UInt32 = 0
  var _selectListener: SelectListener?
  var _readListener: ReadListener?
  var _discoverServiceListener: DiscoverServiceListener?
  var _adapterListener : AdapterListener?
  var _cardClosedListener: CardCloseListener?
  var _unSolicitedEventListener: UnSolicitedEventListener?
  var _connectionListener : ConnectionListener?
  var _encConnectionListener : EncConnectionListener?
  var _scanSecsTimeout: UInt64 = 30000
  var _scanAllowDuplicates: Bool = false
  var _scanStopScanOnWrite: Bool = false
  static var instanceCount : UInt32 = 0
  static var etherApiInstances = [UInt32 : EtherAPI]()
  var _secureSessionManger : FrameworkSecureSession?
  var _appId : UInt8 = 0
  
  public static func CreateInstance (adapterConnectionString:String,  App_ID:UInt8, secsTimeout:Int64, allowDuplicates:Bool, stopScanOnWrite:Bool, adapterListener : AdapterListener ) ->UInt32{
    let etherApi = EtherAPI()
    etherApiInstances[instanceCount] = etherApi
    etherApi.instanceID = instanceCount
    let cc = instanceCount
    instanceCount += 1
    etherApi._adapterListener = adapterListener
    etherApi._appId = App_ID

    if (adapterConnectionString.hasPrefix("BLE")) {
      etherApi._adapter = EtherBTAdapter()
      etherApi._adapter?.Init(servicePort: App_ID, secsTimeout: secsTimeout, allowDuplicates:allowDuplicates,stopScanOnWrite:stopScanOnWrite)
      etherApi.transport = EtherTransportProtocol(servicePort:App_ID, interfaceKind: etherApi._adapter!.GetInterface(), messageProtocol: TMessageProtocol.APP)
      etherApi.SetupCardListeners(adapter: etherApi._adapter!)
    }
    else{
      
    }
    return cc
  }
  
  public static func CreateDFUInstance (adapterConnectionString:String,  App_ID:String, secsTimeout:Int64, allowDuplicates:Bool, stopScanOnWrite:Bool, adapterListener : AdapterListener ) ->UInt32{
    let etherApi = EtherAPI()
    etherApiInstances[instanceCount] = etherApi
    etherApi.instanceID = instanceCount
    let cc = instanceCount
    instanceCount += 1
    etherApi._adapterListener = adapterListener
    
    if (adapterConnectionString.hasPrefix("BLE")) {
      etherApi._adapter = EtherBTAdapter()
      etherApi._adapter?.Init_DFU(servicePort: App_ID, secsTimeout: secsTimeout, allowDuplicates:allowDuplicates,stopScanOnWrite:stopScanOnWrite)
      etherApi.transport = EtherTransportProtocol(servicePort: 0, interfaceKind: etherApi._adapter!.GetInterface(), messageProtocol: TMessageProtocol.APP)
      etherApi.SetupCardListeners(adapter: etherApi._adapter!)
    }
    else{
      
    }
    return cc
  }
  
  public static func GetEtherApiInstance (instanceId : UInt64) ->(EtherAPI){
    let cc = etherApiInstances[UInt32(instanceId)]
    return cc!
  }
  
  public override init () {
    super.init()
  }
  
  func hasReadListener()->Bool{
    if (_readListener != nil){
      return true
    }
    return false;
  }
  
  func GetDelimitedString( data: String )->[UInt8]{
    // Construct payload as series of delimited strings
    var payload : [UInt8]
    if data.lengthOfBytes(using: .utf8)  == 0 {
      payload = [UInt8]()
      payload.append(0)
    } else {
      payload = data.utf8.map{ UInt8($0) }
      payload.append(EtherTransportProtocol.DELIMITER)
    }
    return payload;
  }
  func GetEndedString( data: String )->[UInt8]{
    // Construct payload as series of delimited strings
    var payload : [UInt8]
    if data.lengthOfBytes(using: .utf8)  == 0 {
      payload = [UInt8]()
      payload.append(0)
    } else {
      payload = Array(data.utf8)
      payload.append(0)
    }
    return payload;
  }

	func  GetEthernomTypeValue(jObj: Any , encoding:Int)->[UInt8]?  {
		if(encoding == ETH_STRING_AS_UNICODE) {
			let value = jObj as! String;
			let s = GetDelimitedString(data:value);
			return s;
		
		}else if(encoding == ETH_STRING_AS_ASUTF8) {
			let value = jObj as! String;
			let s = GetDelimitedString(data:value);
			return s;
		
		}else if(encoding == ETH_INT_AS_BYTE) {
			let value = jObj as! Int;
			var s = [UInt8]();
			let b = UInt8(value)
			s.append(b)
			return s;
		
		}else if(encoding == ETH_INT_AS_2BYTE) {
			let value = jObj as! UInt16;
			let array = withUnsafeBytes(of: value.littleEndian) {Array($0)}
			var s = [UInt8]();
			s.append(array[0]);
			s.append(array[1]);
			return s;
		
		}else if(encoding == ETH_INT_AS_4BYTE){
			let value = jObj as! UInt32;
			let array = withUnsafeBytes(of: value.littleEndian) {Array($0)}
			var s = [UInt8]();
			s.append(array[0]);
			s.append(array[1]);
			s.append(array[2]);
			s.append(array[3]);
			return s;
			
		}else if(encoding == ETH_STRING_AS_HEX){
			let string = jObj as! String
      //print(string);
      var s = [UInt8]();
      s = string.hexa
      return s;

		}else if(encoding == ETH_AS_ARRAY){
			let array = jObj as! [UInt8]
			return array;
			
		}else{
			//print("unknown encoding:" + String(encoding))
			return nil
		}
	}
  
  func AddToPayload(jObj: [Any])->[UInt8]?{
    var payload = [UInt8]()
    var i = 0
    for x  in jObj as! [[String:Any]]{
      let kindex = x.keys.startIndex
      let s = x.keys[kindex]
      let obj = x[s]
      if obj is NSString {
        let o = String(describing: obj!)
        if i == (jObj.count - 1){
          let sEnd = GetEndedString(data:o)
          payload.append(contentsOf: sEnd)
        }else{
          let sEnd = GetDelimitedString(data:o)
          payload.append(contentsOf: sEnd)
        }
      }else if obj is NSNumber{
        let o = obj as! UInt8
        payload.append(o)
      
      }else{
        let encoding_obj:[String: Any] = obj as! [String : Any];
        let encoding_payload:[UInt8] = GetEthernomTypeValue(jObj: encoding_obj["value"] as Any, encoding: encoding_obj["encoding"] as! Int)!
        for i in 0..<encoding_payload.count{
          payload.append(encoding_payload[i])
        }
      }
      i = i + 1
    }
    return payload;
  }
  
  
  
  func SetupCardListeners(adapter: EtherCommAdapter) {
    _adapter?.SetDiscoverServiceEventListener(listener: self)
    _adapter?.SetCardEventListener(listener: self)
    _adapter?.SetAdapterEventListener(listener: self)
  }
  
  func onAdapterOpenSuccess(resultCode: Int){
    _adapterListener?.onAdapterOpenSuccess(resultCode: resultCode);
  }
  func onAdapterOpenFail(resultCode: Int, hwSpecificError: Int){
    _adapterListener?.onAdapterOpenFail(resultCode: resultCode, hwSpecificError: hwSpecificError);
  }
  func ClearUnsolicitedEventListener() {
    self._unSolicitedEventListener = nil
  }
  
  func ClearReadListener() {
    self._readListener = nil
  }
  
  func StopDiscovery() {
    self._adapter?.StopDiscovery()
  }
  
  func CardClose(closeListener: CardCloseListener) {
    _cardClosedListener = closeListener
    _discoverServiceListener = nil
    _adapter?.CardClose()
  }
  
  func SubscribeToUnsolictedEvents(unSolicitedEventListener: UnSolicitedEventListener) {
    _readListener = nil
    _unSolicitedEventListener = unSolicitedEventListener
    ClearReadListener()
  }
  
  
  @objc func DiscoverDevices(discoverServiceListener : DiscoverServiceListener){
    _discoverServiceListener = discoverServiceListener
    _adapter?.Discover()
  }
  
  func onConnectionDropped(resultCode: Int) {
    if(_connectionListener != nil){
      _connectionListener?.onConnectionDropped(resultCode: resultCode)
    }
  }
  
  func onSecureConnectionEstablished(resultCode: Int) {
    if(_encConnectionListener != nil){
      _encConnectionListener?.onSecureConnectionEstablished(resultCode: resultCode)
    }
  }
  func onSecureConnection( encConnectionListener : EncConnectionListener) {
    _encConnectionListener = encConnectionListener
  }
  func DoKeyExchange(pin : String){
    // kick off dh key exchange
    if _secureSessionManger == nil{
      let btClient = _adapter as! EtherBTAdapter
      _secureSessionManger = FrameworkSecureSession(
          bleClient: btClient,
          secureAppSessionEstablished:secureAppSessionEstablished,
          appMessageReceived: handle_command)
    }
    _secureSessionManger?.DoKeyExchange(pin: pin, cmd : _appId)
  }
  
  
   func handle_command(transportCmdByte: UInt8, value: [UInt8]){
   //    print(value);
       if(transportCmdByte == PSD_MGR_PORT){
        print("app message received") // call readsuccess listener
         //handle_command_psd_mgr(value: value)
       }else if(transportCmdByte == GENERIC_PORT){
           print("unexpected generic port number received")
       }
      }
  func secureAppSessionEstablished(result : EtherErrorValue) {
      if _encConnectionListener != nil{
        _encConnectionListener?.onSecureConnectionEstablished(resultCode: result)
      }
  }
  // MARK: - onCardDisconnected
  func onCardDisconnected( connectionListener : ConnectionListener) {
    _connectionListener = connectionListener
  }
  func onCardConnectionDropped(resultCode: Int) {
    if(_connectionListener != nil){
      _connectionListener?.onConnectionDropped(resultCode: resultCode)
    }
  }
  
  func onServiceDiscover(resultCode: Int, peripheralID: String, deviceName: String, dSerialNum: String ) {
    _discoverServiceListener?.onServiceDiscover(resultCode: resultCode, peripheralID: peripheralID, deviceName: deviceName, dSerialNum : dSerialNum)
  }
  
  func onServiceDiscoverEnd(resultCode: Int) {
    _discoverServiceListener?.onServiceDiscoverEnd(resultCode: resultCode)
  }
  
  func onServiceDiscoverFail(resultCode: Int, hwSpecificError : Int) {
    _discoverServiceListener?.onServiceDiscoverFail(resultCode: resultCode, hwSpecificError: hwSpecificError)
  }
  
  func Select(cardInfo: CardInfo, selectListener: SelectListener) {
    _selectListener = selectListener;
    _adapter?.CardOpen(cardInfo: cardInfo)
  }
  
  func Write(json: String, readListener: ReadListener) {
    // create a Transport layer packet
    _unSolicitedEventListener = nil
    if(_readListener != nil) { _readListener = nil; }
    _readListener = readListener
    
    let data = json.data(using: .utf8)!
    do {
      let jsonResponse = try JSONSerialization.jsonObject(with: data, options:[JSONSerialization.ReadingOptions.mutableContainers]) as! [Any]
//      let currentPayload = [UInt8]()
      let appMessage = AddToPayload(jObj:jsonResponse)
      _unSolicitedEventListener = nil;
      let msg = transport.GetPayload(data: appMessage!);
      _adapter!.WriteToCard(buffer:msg);
    } catch let error as NSError {
      print(error)
    }
  }
  
	func Write_DL(json: String, readListener: ReadListener) {
		// create a Transport layer packet
		_unSolicitedEventListener = nil
    if(_readListener != nil) { _readListener = nil; }
    _readListener = readListener
    
    print(_readListener as Any);
    
		let data = json.data(using: .utf8)!
		do {	
			let jsonResponse = try JSONSerialization.jsonObject(with: data, options:[JSONSerialization.ReadingOptions.mutableContainers]) as! [Any]
		
			//let currentPayload = [UInt8]()
			let appMessage = AddToPayload(jObj:jsonResponse)
      //print(appMessage);
			_unSolicitedEventListener = nil;
		
			let msg = transport.GetPayload_DL(data: appMessage!);
			_adapter!.WriteToCard(buffer:msg);
		} catch let error as NSError {
			print(error)
		}
	}
  
  func Write_Generic(json: String, readListener: ReadListener) {
    // create a Transport layer packet
    _unSolicitedEventListener = nil
    if(_readListener != nil) { _readListener = nil; }
    _readListener = readListener
    
    let data = json.data(using: .utf8)!
    do {
      let jsonResponse = try JSONSerialization.jsonObject(with: data, options:[JSONSerialization.ReadingOptions.mutableContainers]) as! [Any]
    
      //let currentPayload = [UInt8]()
      let appMessage = AddToPayload(jObj:jsonResponse)
      //print(appMessage);
      _unSolicitedEventListener = nil;
    
      let msg = transport.GetPayload_Generic(data: appMessage!);
      _adapter!.WriteToCard(buffer:msg);
    } catch let error as NSError {
      print(error)
    }
  }

  func WriteEncrypted( json: String, doEncrypt: Bool, readListener: ReadListener) {
      // create a Transport layer packet
    if _secureSessionManger == nil{
      let btClient = _adapter as! EtherBTAdapter
      _secureSessionManger = FrameworkSecureSession(
          bleClient: btClient,
          secureAppSessionEstablished:secureAppSessionEstablished,
          appMessageReceived: handle_command)
    }
      _unSolicitedEventListener = nil
      if(_readListener != nil) { _readListener = nil; }
      _readListener = readListener
      
      let data = json.data(using: .utf8)!
      do {
        let jsonResponse = try JSONSerialization.jsonObject(with: data, options:[JSONSerialization.ReadingOptions.mutableContainers]) as! [Any]
  //      let currentPayload = [UInt8]()
        let appMessage = AddToPayload(jObj:jsonResponse)
        _unSolicitedEventListener = nil;
        _secureSessionManger?.WriteDataToCardEncrypted(doEncrypt: doEncrypt,AppData: appMessage!)
      } catch let error as NSError {
        print(error)
      }
    }

  
  // MARK: - CardEventListener
  
  func onCardOpenSuccess(resultCode: Int) {
    // the card was opened
    // inform the app side
    _selectListener?.onSelectSuccess(resultCode: resultCode)
  }
  
  func onCardOpenFail(resultCode: Int, hwSpecificError: Int) {
    _selectListener?.onSelectFail(resultCode: EtherError.ERR_ETH_SELECT_FAILED, hwSpecificError: resultCode)
  }
  
  func onCardClosedSucess(resultCode: Int) {
    _cardClosedListener?.onCardCloseSuccess(resultCode: resultCode)
  }
  
  func onCardClosedByCard(resultCode: Int) {
    _selectListener?.onDisconnect(resultCode: EtherError.ERR_ETH_DISCONNECTED, hwSpecificError: resultCode)
  }
  
  func onCardClosedFail(resultCode: Int, hwSpecificError: Int) {
    _selectListener?.onDisconnect(resultCode: EtherError.ERR_ETH_DISCONNECTED, hwSpecificError: resultCode)
  }
  
  func onWriteToCardSuccess(resultCode: Int) {
    //debugPrint("Write to card succeeded")
  }
  
  func onWriteToCardFail(resultCode: Int, hwSpecificError: Int) {
    //debugPrint("Write to card failed")
  }
  
  func onReadFromCardFail(resultCode: Int, hwSpecificError: Int) {
    //debugPrint("read from card failed")
    if _readListener != nil {
      // only deliver the payload
      _readListener?.onReadSuccess(resultCode: resultCode, payload: [0]);
    }
  }
  
  @objc func parseToOutputJSON(payload:[UInt8], outputJSONDef:String)->String{
    var jcc = [String: Any]()
    var pp = 0
    do {
      let data = outputJSONDef.data(using: .utf8)!
      let def = try JSONSerialization.jsonObject(with: data, options:[JSONSerialization.ReadingOptions.mutableContainers]) as! [Any]
      for x  in def as! [[String:Any]]{
        
        //If inbound message structure > payload.length
        if(pp == payload.count){
          break;
        }
        
        let kindex = x.keys.startIndex
        let sk = x.keys[kindex]
        let obj = x[sk]
        //print(sk)
        let etype = obj as! UInt8
        if etype == ETH_BYTE{
          var val = payload[pp]
          if(val < 0){
            val = val & 0xFF
          }
          pp += 1
          jcc[sk] = val
        }
        else if etype == ETH_2BYTE {
          var val:Int32 = Int32(payload[pp+1]) * 256 + Int32(payload[pp] & 0xFF)
          if val < 0 {
              val = val & 0xFFFF;
          }
          pp += 2;
          jcc[sk] = val
        }
		else if etype == ETH_4BYTE {
          var val:Int = 0
          for b in payload {
            val = val << 8
            val = val | Int(b)
          }
          pp += 4;
          jcc[sk] = val
        }
        else if (etype == ETH_UTF8STRING ) {
          var bytes = [UInt8]()
          while((payload[pp] != EtherTransportProtocol.DELIMITER) && (payload[pp] != 0)){
            bytes.append(payload[pp]);
            pp += 1;
          }
          pp += 1; // past delims
          let s = String(data: Data(bytes), encoding: .utf8)
          jcc[sk] = s;
        }
        else if (etype == ETH_PAYLOAD ) {
          var iarr = [UInt8]()
          for b  in payload {
              var val = b
              if val < 0 {
                  val = val & 0xFF
              }
              iarr.append(val);
          }
          jcc[sk] = iarr
        }
      }
      return try String(data: JSONSerialization.data(withJSONObject: jcc as Any), encoding: String.Encoding.utf8)!
    } catch let error as NSError {
      print(error)
    }
    return ""
}

  func onReadFromCardSuccess(resultCode: Int, buffer: [UInt8]) {
  // we are coming in here with in theory a full transport layer buffer
    //print("Read from card success")
    
    // in the old code we check  buffer[1] for this also
    if (buffer[0] == transport.GetServicePort() || buffer[0] == transport.GetDLServicePort() || buffer[0] == transport.GetGenericServicePort()){
    /*
    // read agrees with current services
    if (buffer.count > EtherTransportProtocol.ETH_HEADER_SIZE) {
      let cmd1 = buffer[0]
      let cmd2 = buffer[1]

      let svcPort = transport.GetServicePort()
      var protocolError = false

      if (cmd1 != svcPort) {
        protocolError = true
      }

      let res = svcPort | 0x80

      if cmd2 != res {
        protocolError = true
      }

      let cksum = transport.GetTransportMessageCheckSum(packet: buffer)

      if cksum != buffer[EtherTransportProtocol.ETH_HEADER_SIZE-1] {
        protocolError = true
      }
      */

      if _readListener != nil {
        // only deliver the payload
        if let payload = try? transport.GetApplicationData(data: buffer) {
          _readListener?.onReadSuccess(resultCode: resultCode, payload: payload)
        }
      }else if _unSolicitedEventListener != nil {
        if let payload = try? transport.GetApplicationData(data: buffer) {
          _unSolicitedEventListener?.onUnsolicitedEvent(resultCode: resultCode, payload: payload)
        }
      }
    }
  }
}
