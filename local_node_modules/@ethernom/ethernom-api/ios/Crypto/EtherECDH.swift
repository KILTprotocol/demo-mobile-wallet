//
//  EtherECDH.swift
//  EthernomApi
//
//  Created by Fred Covely on 1/11/20.
//  Copyright Â© 2020 Facebook. All rights reserved.
//

import Foundation
let CM_AUTHENTICATE_RSP:UInt8 = 0x88;
let FLAG_CONTAIN_ENCRYPTION_HDR = 0x80
let ALLOWED_SEQ_NUM_SKIPS       = 4
let APP_FLAG_H2C      = 0x80
let APP_FLAG_ENCRYPT  = 0x40
let APP_CMD_MASK      = ~APP_FLAG_ENCRYPT

let APP_H2C_KEY_EXCHANGE  = (UInt8)( APP_FLAG_H2C | 0x01)
let APP_H2C_ENCRYPT_START = (UInt8)( APP_FLAG_H2C | 0x02)
let APP_H2C_MSG           = (UInt8)( APP_FLAG_H2C | 0x11)

let APP_C2H_KEY_EXCHANGE  = 0x01;
let APP_C2H_ENCRYPT_START = 0x02;
let APP_C2H_MSG           = 0x11;

let APP_ERROR_SEQUENCE  = 0x81;
let APP_ERROR_AUTH      = 0x82;
let APP_ERROR_INTERNAL  = 0x83;
let APP_ERROR_FORMAT    = 0x84;

class EtherECDH:NSObject {

  var _authenticating = false;
  
  
  func dumpKey(lbl:String, key : SecKey){
      var error: Unmanaged<CFError>?
      if let cfdata = SecKeyCopyExternalRepresentation(key, &error) {
          let data:Data = cfdata as Data
          print(lbl+":Length:"+String(data.count)+":"+data.hexa)
      }
  }
    
  func lunsDerDecoder(der : [UInt8])->([UInt8],Bool){
         let len_r :Int = Int(der[3])
         print("r length: "+String(len_r))
         let len_s : Int = Int(der[5 + Int(len_r)])
         print("s length: "+String(len_s))
         var sig: [UInt8]=[]
         
             if (der[0] != 0x30 ||
             len_r <= 0 || len_r > 33 || len_s <= 0 || len_s > 33 ||
             der[2] != 0x02 || der[4 + len_r] != 0x02
            )
         {
             // error
             return (sig,false)
         }
    
       print(der)
         if len_r <= 32 {
             //memset(sig, 0, 32 - len_r);
             //memmove(sig + 32 - len_r, der + 4, len_r);
             let fill = [UInt8](repeatElement(0, count: 32 - len_r))
             sig.append(contentsOf: fill)
             let movePart = der[4...4+len_r-1]
             sig.append(contentsOf: movePart)
          } else {
             //memmove(sig, der + 4 + 1, 32);
             let movePart = der[4+1...4+32]
              sig.append(contentsOf: movePart)
          }
          if (len_s <= 32) {
             //memset(sig + 32, 0, 32 - len_s);
             //memmove(sig + 64 - len_s, der + 6 + len_r, len_s);
              let movePart = der[6+len_r...6+len_s+len_r-1]
              sig.append(contentsOf: movePart)
          } else {
             // memmove(sig + 32, der + 6 + len_r + 1, 32);
              let movePart = der[6+len_r+1...6+len_r+32]
             sig.append(contentsOf: movePart)
          }
          return (sig,true);
     }

  func generate_auth_rsp(challenge: Data, pubKey : String, privKey : String)-> [UInt8]?{
      
      var DERprivPublicKey:String = "04"
      DERprivPublicKey += pubKey
      DERprivPublicKey += privKey
            
      //print("challenge:" + challenge.hexEncodedString())
      //print("private key: ",(json_data!["pkey"] as! String))
      let byteData = DERprivPublicKey.hexa
      var keyData = NSData(bytes: byteData, length: byteData.count)
      var keyDict:CFDictionary {
          return[
              kSecAttrKeyType as String: kSecAttrKeyTypeECSECPrimeRandom,
              kSecAttrKeyClass as String: kSecAttrKeyClassPrivate,
              ] as CFDictionary
      }
      var error: Unmanaged<CFError>?
      guard let privKey = SecKeyCreateWithData(keyData as CFData, keyDict, &error) else{
            print("Cannot create users private key: " + error.debugDescription)
            return nil
      }
      let hash = Ether_AESEAX.sha256(data: challenge)
      let cfHashData = hash as CFData
      
      let algorithm: SecKeyAlgorithm = .ecdsaSignatureDigestX962SHA256
      let signature = SecKeyCreateSignature(privKey, algorithm, cfHashData as CFData, &error) as Data?

      let Buffer = [UInt8] (signature!)
      let (rawSig, cc) = lunsDerDecoder(der: Buffer)
      
      var payload = [UInt8]()
      payload.append(CM_AUTHENTICATE_RSP);
      payload.append(INT8NULL);
      payload.append(64);
      payload.append(INT8NULL);
      
      if (cc){
          for num in rawSig{
            payload.append(num);
          }
      }
      _authenticating = true;
      return payload
  }
}
  
