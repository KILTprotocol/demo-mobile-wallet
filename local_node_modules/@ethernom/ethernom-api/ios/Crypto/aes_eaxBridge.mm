//
//  aes-eaxBridge.m
//  iostestbed
//
//  Created by Fred Covely on 1/13/20.
//  Copyright Â© 2020 Fred Covely. All rights reserved.
//

#import <Foundation/Foundation.h>
#import "aes_eaxBridge.h"
#include "eax.h"
//#import "testvec.h"
#include <cstdint>
#include <cstddef>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <utility>
#include <memory>
#include <unordered_map>
#include <stdexcept>

const char *t_name[] = {
    "KEY", "HDR", "PTX", "CTX", "TAG", "NCE", "IV ", "VEC", "RPT", "END", "REM", "MDE"
};
const size_t t_length = sizeof(t_name) / sizeof(t_name[0]);
#define RET_TYPE_DEFINED
typedef int  ret_type;
typedef ret_type t_init_and_key(const unsigned char[], unsigned long, void*);
typedef ret_type t_init_message(const unsigned char*, unsigned long, void*);
typedef ret_type t_auth_header(const unsigned char*, unsigned long, void*);
typedef ret_type t_auth_data(const unsigned char*, unsigned long, void*);
typedef ret_type t_crypt_data(unsigned char*, unsigned long, void*);
typedef ret_type t_compute_tag(unsigned char*, unsigned long, void*);
typedef ret_type t_encrypt(unsigned char*, unsigned long, void*);
typedef ret_type t_decrypt(unsigned char*, unsigned long, void*);
typedef ret_type t_encrypt_message(
    const unsigned char*, unsigned long,
    const unsigned char*, unsigned long,
    unsigned char*, unsigned long,
    unsigned char*, unsigned long,
    void*);
typedef ret_type t_decrypt_message(
    const unsigned char*, unsigned long,
    const unsigned char*, unsigned long,
    unsigned char*, unsigned long,
    unsigned char*, unsigned long,
    void*);
typedef ret_type t_end(void*);

#if defined(__cplusplus)

#endif

typedef struct
{   char                *name;
    t_init_and_key      *init_and_key;
    t_init_message      *init_message;
    t_auth_header       *auth_header;
    t_auth_data         *auth_data;
    t_crypt_data        *crypt_data;
    t_compute_tag       *compute_tag;
    t_encrypt           *encrypt;
    t_decrypt           *decrypt;
    t_encrypt_message   *encrypt_message;
    t_decrypt_message   *decrypt_message;
    t_end               *end;
} mode_fns;

#define boiler \
    f->init_and_key =    (t_init_and_key*)mode(init_and_key); \
    f->init_message =    (t_init_message*)mode(init_message); \
    f->auth_header =     (t_auth_header*)mode(auth_header); \
    f->auth_data =       (t_auth_data*)mode(auth_data); \
    f->crypt_data =      (t_crypt_data*)mode(crypt_data); \
    f->compute_tag =     (t_compute_tag*)mode(compute_tag); \
    f->encrypt =         (t_encrypt*)mode(encrypt); \
    f->decrypt =         (t_decrypt*)mode(decrypt); \
    f->encrypt_message = (t_encrypt_message*)mode(encrypt_message); \
    f->decrypt_message = (t_decrypt_message*)mode(decrypt_message); \
    f->end =             (t_end*)mode(end);
#define mode(f) eax_##f
void mode(functions)(mode_fns f[1])
{
//    f->name = "EAX";
    boiler
}
#undef mode


@implementation AES_EAX
{
}

uint8_t * convertToUintArray(NSData * data){
  NSUInteger len = [data length];
  Byte *byteData = (Byte*)malloc(len);
  memcpy(byteData, [data bytes], len);
  return byteData;
}

// init and return a context
- (uint8_t *) aes_InitContext
{
  eax_ctx *data = (eax_ctx *)malloc(sizeof(eax_ctx));
  return (uint8_t *)data;
}

void dumpValue (const uint8_t *dataIn, size_t dataInLength)
{
    NSUInteger capacity = dataInLength * 2;
    NSMutableString *sbuf = [NSMutableString stringWithCapacity:capacity];
    const unsigned char *buf = (const unsigned char *)dataIn;
    NSInteger i;
    for (i=0; i<dataInLength; ++i) {
      [sbuf appendFormat:@"%02X", (NSUInteger)buf[i]];
    }
    NSLog(sbuf);
}

void NSDumpVal(NSData * data){
  NSUInteger capacity = data.length * 2;
  NSMutableString *sbuf = [NSMutableString stringWithCapacity:capacity];
  const unsigned char *buf = (const unsigned char *)data.bytes;
  NSInteger i;
  for (i=0; i<data.length; ++i) {
    [sbuf appendFormat:@"%02X", (NSUInteger)buf[i]];
  }
  NSLog(sbuf);
}

// encryption must be called before tag/mac!
- (NSData *) aes_EAXDoEncrypt : (uint8_t *)dctx key: (NSData *) key nonce: (NSData *) nonce plainText: (NSData * )plaintext;
{
//  NSDumpVal(key);
//  NSDumpVal(nonce);
//  NSDumpVal(plaintext);
  unsigned long key_len = AES_BLOCK_SIZE;
  eax_ctx * ctx = (eax_ctx *)dctx;
  NSLog(@"aes_EAXDoEncrypt");
  mode_fns f[1];
  size_t nce_len = [nonce length];
  size_t ptx_len = [plaintext length];
  uint8_t * pkey = convertToUintArray(key);
  uint8_t * pnonce = convertToUintArray(nonce);
  uint8_t * ptext = convertToUintArray(plaintext);
/*
  dumpValue(pkey, key_len);
  dumpValue(pnonce, 16);
  dumpValue(ptext, ptx_len);
*/
  
    // convert to uint 8 buffers

  eax_functions(f);
  
  f->init_and_key(pkey, key_len, ctx);
  f->init_message(pnonce, nce_len, ctx);

  //   FHC might need this    f->auth_header(hdr, hdr_len, contx);

  uint8_t *enc_buf = new uint8_t[ptx_len];
  memcpy(enc_buf, ptext, ptx_len);
  f->encrypt(enc_buf, ptx_len, ctx);
//  dumpValue(enc_buf, ptx_len);
  NSData *data = [NSData dataWithBytes:enc_buf length:ptx_len];
//  NSDumpVal(data);
  delete[] enc_buf;
  
  //  v.vector_out(vec_no);
  delete [] pkey;
  delete [] pnonce;
  delete [] ptext;
  return data;
}

// mac = tag
- (uint8_t *) aes_GetTag: (uint8_t *)dctx requestedMacLength : (size_t)requestedMacLength
{
    eax_ctx * ctx = (eax_ctx *)dctx;
    mode_fns f[1];
    eax_functions(f);
  
    uint8_t *enc_tag = new uint8_t[requestedMacLength];
    f->compute_tag(enc_tag, requestedMacLength, ctx);
    f->end(ctx);
    return enc_tag;
}


- (NSData *) aes_EAXDoDecrypt : (uint8_t *)dctx key :(NSData *) key nonce: (NSData *) nonce crypt_text: (NSData * )crypt_text
{
  //  NSDumpVal(key);
  //  NSDumpVal(nonce);
  //  NSDumpVal(plaintext);
  unsigned long key_len = AES_BLOCK_SIZE;
  eax_ctx * ctx = (eax_ctx *)dctx;
  mode_fns f[1];
  size_t nce_len = [nonce length];
  size_t crypt_text_len = [crypt_text length];
  uint8_t * pkey = convertToUintArray(key);
  uint8_t * pnonce = convertToUintArray(nonce);
  uint8_t * pcrypt_text = convertToUintArray(crypt_text);
  
//    dumpValue(pkey, key_len);
//    dumpValue(pnonce, 16);
//    dumpValue(pcrypt_text, crypt_text_len);
  
  eax_functions(f);
  f->init_and_key(pkey, key_len, ctx);
  f->init_message(pnonce, nce_len, ctx);

    // fhc might need      f->auth_header(hdr, hdr_len, contx);

  uint8_t *dec_buf = new uint8_t[crypt_text_len];
  memcpy(dec_buf, pcrypt_text, crypt_text_len);

  f->decrypt(dec_buf, crypt_text_len, ctx);
  NSData *data = [NSData dataWithBytes:dec_buf length:crypt_text_len];
  NSDumpVal(data);
  delete[] dec_buf;

  return data;
}
@end
