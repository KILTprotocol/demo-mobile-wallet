//
//  EtherAESEAX.swift
//  EthernomPasswordManagerMobile
//
//  Created by Fred Covely on 1/14/20.
//  Copyright Â© 2020 Facebook. All rights reserved.
//

import Foundation


public class Ether_AESEAX : EtherCryptoMgrProtocol
{
  var _publicKey : SecKey?
  var _privateKey : SecKey?
  var _cardPublicKey : SecKey?
  var _sessionKey : [UInt8]?
  let _macLength = 8
  
  init() {
    _publicKey = nil
    _privateKey = nil
    _cardPublicKey = nil
    _sessionKey = nil
  }
  
  
  // nonce
  var _nce_sequence : UInt32 = 0
  
  var attributes: [String:Any] =
    [
      kSecAttrKeyClass as String: kSecAttrKeyClassPrivate,
      kSecAttrKeyType as String: kSecAttrKeyTypeECSECPrimeRandom,
  ]

  func initCryptoLib(libname: String) {
    NSLog("init EtherECDH_AESEAX")
  }

  public static func sha256(data:Data) -> Data {
      var hashData = Data(count: Int(CC_SHA256_DIGEST_LENGTH))
      _ = hashData.withUnsafeMutableBytes {digestBytes in
          data.withUnsafeBytes {messageBytes in
              CC_SHA256(messageBytes, CC_LONG(data.count), digestBytes)
          }
      }
      return hashData
  }

  func keyToHexString(key :SecKey)->String{
    var error: Unmanaged<CFError>?
    if let cfdata = SecKeyCopyExternalRepresentation(key, &error) {
             let data:Data = cfdata as Data
             return data.hexa
         }
    return ""
  }

  func GenerateKeyPair() {
    var error: Unmanaged<CFError>?
    var keyDict:CFDictionary {
        return
            [
                kSecAttrKeyClass as String: kSecAttrKeyClassPrivate,
                kSecAttrKeySizeInBits as String:      256,
                kSecAttrKeyType as String: kSecAttrKeyTypeECSECPrimeRandom,
            ] as CFDictionary
    }
    _privateKey = SecKeyCreateRandomKey(keyDict, &error)
    if(_privateKey == nil){
      print(error.debugDescription)
    }
    else{
      _publicKey = SecKeyCopyPublicKey(_privateKey!)
    }
  }

  func getKeyAsData (key : SecKey?)-> Data?{
    var error: Unmanaged<CFError>?
    if key == nil {
      return nil
    }
    else{
      let cfdata = SecKeyCopyExternalRepresentation(key!, &error)
      return cfdata as Data?
    }
  }
  
  // caution we remove the leading DER 04 for the card here!
  func GetPublicKeyForCard() -> [UInt8] {
    let b = getKeyAsData(key: _publicKey)
    var cc = [UInt8](b!)
    cc.removeFirst()
    print("get public key for send to card:")
    print(keyToHexString(key: _publicKey!))
    return cc
  }

  func GetPublicKey()->Data?{
    return getKeyAsData(key: _privateKey)
  }
  
  func GetPrivateKey() -> Data? {
    return getKeyAsData(key: _privateKey)
  }
  
  func GetCardPublicKey() -> Data? {
    return getKeyAsData(key: _cardPublicKey)
  }
  
  func GeneratePublicKeyFromPrivate(privateKey: Data) {
    NSLog("no op for us")
  }
  
  func SetCardPublicKey(cardPublicKeyBytes : [UInt8]) {
    var error: Unmanaged<CFError>?
    // make it a DER
    var derkey = [UInt8]()
    derkey.append(04)
    derkey.append(contentsOf: cardPublicKeyBytes)
    attributes[kSecAttrKeyClass as String] = kSecAttrKeyClassPublic
    let otherData = NSData(bytes: derkey, length: derkey.count)
    _cardPublicKey = SecKeyCreateWithData(otherData as CFData, attributes as CFDictionary, &error)
    if _cardPublicKey == nil {
        print(error.debugDescription) //Error Domain Code=-50 "RSA private
        return
    }
  }
  
  func InitializeRandomSequence() {
    // need a random uint32, but not near an overflow, so will get
    // a random uint16 and go up
    let number = UInt32.random(in: 0 ... 65536)
    _nce_sequence = number
  }
  
  func GetNextSequence()->UInt32{
    _nce_sequence += 2
    return _nce_sequence
  }
  
//  func DoDH(cardPublicKeyHexBuffer:String,  appKey:SecKey)->CFData{
  func GenerateSessionKeyFromSecret(pin:String){
      
    var error: Unmanaged<CFError>?
    let exchangeOptions: [String: Any] = [:]
    let sharedSecret = SecKeyCopyKeyExchangeResult(_privateKey!, SecKeyAlgorithm.ecdhKeyExchangeCofactor, _cardPublicKey!, exchangeOptions as CFDictionary, &error)
    print("host public key")
    print(keyToHexString(key : _publicKey!))
    print("host private key:")
    print(keyToHexString(key : _privateKey!))
    print("card public key:")
    print(keyToHexString(key : _cardPublicKey!))
    let sc = sharedSecret! as Data
    print("shared secret:"+sc.hexaSpaced)
    
    _sessionKey = [UInt8](sc)
    let pdata = Data(pin.utf8)
    _sessionKey?.append(contentsOf: pdata)
    let s256val = Ether_AESEAX.sha256(data: Data(_sessionKey!))
    let bigkey = [UInt8](s256val)
    _sessionKey?.removeAll()
    for i in 0...15{
      _sessionKey?.append(bigkey[i])
    }
    
    print("computed session key")
    print(_sessionKey!.hexaSpaced)
  }
  
 
    func EmptyEncryptionHeader(payload: Data) -> Data? {
      // we need to calc the nonce which is in the enc header, so create it here
      // new create actual encryption header and payload
      let cmd : UInt8 = APP_H2C_MSG
      let len = UInt16(payload.count)
      let encHeader = EtherEncHeader(cmd: cmd, status:  0, length: len, sequence: GetNextSequence())
      print("clear encheader: nonce,key,data")
      print(payload.hexa)
      
      var packet = encHeader.GetHeaderBuffer()
      packet.append(contentsOf: payload)

      return Data(packet)
    }
  // we use the last calced nonce
  func EncryptData(encPayload: Data) -> Data? {
    let aes_eax_bridge = AES_EAX()
    let ctx : UnsafeMutablePointer<UInt8> =  aes_eax_bridge.aes_InitContext()
    let skey = Data(_sessionKey!)
    
    // we need to calc the nonce which is in the enc header, so create it here
    // new create actual encryption header and payload
    let cmd : UInt8 = APP_H2C_MSG | UInt8(APP_FLAG_ENCRYPT)
    let len = UInt16(encPayload.count)
    let encHeader = EtherEncHeader(cmd: cmd, status:  0, length: len, sequence: GetNextSequence())
    let nonce = encHeader.GetNonce()
    let payload = [UInt8](encPayload)
    print("ENCRYPTING")
    print("nonce,key,data")
    print(nonce.hexa)
    print(_sessionKey!.hexa)
    print(encPayload.hexa)
    let dNonce = Data(nonce)
    
/*    let nsKey = NSData(bytes: _sessionKey, length: _sessionKey!.count)
    let nsNonce = NSData(bytes: nonce, length: nonce.count)
    let nsPayload = NSData(bytes: payload, length: payload.count)
*/
    let encBuffer = aes_eax_bridge.aes_EAXDoEncrypt(ctx, key: skey, nonce:dNonce, plainText:encPayload)
    print("ENCBuffer:")
    print(encBuffer!.hexa)
    // get the mac
    let cmac = aes_eax_bridge.aes_GetTag(ctx, requestedMacLength : _macLength)
    var _encMac = [UInt8]()
    for i in 0...7{
      _encMac.append(cmac![i])
    }
    print("MAC")
    print(_encMac.hexa)
    encHeader.SetMac(mac: _encMac)
    var packet = encHeader.GetHeaderBuffer()
    packet.append(contentsOf: encBuffer!)

    return Data(packet)
  }
  
  // this sends in the Encrypted Header and app data payload within the bigger transport packet
  func DecryptData(encHeader: Data, encAppData: Data) -> Data? {
    
    let aes_eax_bridge = AES_EAX()
    let ctx : UnsafeMutablePointer<UInt8> =  aes_eax_bridge.aes_InitContext()
//    let skey = Data(bytes: &_sessionKey, count: _sessionKey!.count)
    let skey = Data(_sessionKey!)
    // we need the nonce and can grab it directly from the buffer
    var nonce = Data(CopyBytes(payload: [UInt8](encHeader), startIdx: 0, count: 8))
    let padding = [UInt8](repeating: 0, count: 8)
    nonce.append(contentsOf: padding)
    print("DECRYPTING")
       print("nonce,key,data")
       print(nonce.hexa)
    print(skey.hexa)
       print(encAppData.hexa)
    let decryptBuffer = aes_eax_bridge.aes_EAXDoDecrypt(ctx, key: skey, nonce:nonce, crypt_text:encAppData)
    print(decryptBuffer!.hexa)
    return decryptBuffer
    //return Data()
  }
}
