//
//  EtherBTAdapter.swift
//  ethernom-api
//
//  Created by admin on 20/10/2019.
//  Copyright Â© 2019 admin. All rights reserved.
//

import Foundation
import UIKit

// STEP 0.00: MUST include the CoreBluetooth framework
import CoreBluetooth


//*******************************************************************
//BLE constant
//*******************************************************************
let ETH_advertising_serviceUUID = CBUUID(string:"19490016-5537-4F5E-99CA-290F4FBFF142")
let ETH_serviceUUID             = CBUUID(string:"19490001-5537-4F5E-99CA-290F4FBFF142")
let ETH_characteristicUUID      = CBUUID(string:"19490002-5537-4F5E-99CA-290F4FBFF142")

//Ethernom BLE Interface
let ETH_BLE_INTERFACE  : UInt8  = 2

let _downloader_servicePort: UInt8 = 20;

// STEP 0.1: this class adopts both the central and peripheral delegates
// and therefore must conform to these protocols' requirements
class EtherBTAdapter:NSObject, EtherCommAdapter, CBCentralManagerDelegate, CBPeripheralDelegate {

  // for IOS the discovery gives a peripheral object that has to be maintained
  // until we actuall select/connect, we do so here
  static var discoveredPeripherals = Dictionary<String,UUID>()
  static var discoveredPeripheralInstances = Dictionary<String,CBPeripheral>()
  var AdapterEventListener: AdapterListener?
  var _adapterAddress: String = ""
  var _servicePort: UInt8 = 0 // AO on the card or what a dev would call a service
  var eth_advserviceCBUUID:CBUUID = CBUUID.init()
  var _aes_eax : Ether_AESEAX?
  var _transportProtocol = EtherTransportProtocol(servicePort: PSD_MGR_PORT, interfaceKind: TInterface.BLE, messageProtocol: TMessageProtocol.APP)

  // MARK: - Core Bluetooth class member variables
  
  // STEP 0.2: create instance variables of the
  // CBCentralManager and CBPeripheral so they
  // persist for the duration of the app's life
  var _centralManager: CBCentralManager?
  var _periphEthCard: CBPeripheral?
  var _ethCharacteristic : CBCharacteristic?
  var isPoweredOn: Bool?
  var didModifyServices: Bool = false;
  var eth_advServiceUUD = ""
  var maxByteSize: Int = 180;
  var operationCompleteHandler: (() -> Void)?
  var temp_buffer: [UInt8] = [UInt8]()
  
  // encryption hack
  var _readSuccessHandler: (([UInt8]) -> Void?)? = nil
  var _writeCallback:(([UInt8]) -> Void)?

  // MARK: - EtherCommAdapter
  
  var _scanAllowDuplicates: Bool = false
  var _scanMSecsTimeout: Int64 = 30000
  var _isWithoutTimeout: Bool = false
  var _scanStopScanOnWrite: Bool = false
  var _foundCards: [CardInfo] = [CardInfo]()
  
  var CardEventListener: CardListener?
  
  var DiscoverServiceEventListener: DiscoverServiceListener?
  
  // IETHERCOMADAPTER
  func GetInterface() -> TInterface {
    return .BLE
  }
  
  // these need to set the link layer specific address of the BLE adapter, COM/USB adapter or NFC
  // as appropriate to the link layer in question
  func GetAdapterAddress() -> String {
    return _adapterAddress
  }
  
  func SetAdapterAddress(address: String) {
    _adapterAddress = address
  }
  
  func Discover(){
    scanLeDevice(true)
  }
  
  //    func Discover(servicePort: UInt8, secsTimeout: Int64, cardReady: @escaping ()->Void, accountFetched : @escaping ([String])->Void, operationComplete: @escaping()->Void, string_id: String, string_name: String)
  //    {
  //        self.initEthBLE(cardReady: cardReady, accountFetched: accountFetched, operationComplete: operationComplete, string_id: string_id, string_name: string_name)
  //        self.Discover(servicePort: servicePort, secsTimeout: secsTimeout, allowDuplicates: false, stopScanOnWrite: false)
  //    }
  
  func StopDiscovery() {
    scanLeDevice(false)
  }
  
  func CardOpen(cardInfo: CardInfo) {
    debugPrint("found specific ethernom card")
    //for (ci, p) in EtherBTAdapter.discoveredPeripheralInstances{
    let uuid = UUID(uuidString:cardInfo.GetDeviceID());
    let data = _centralManager!.retrievePeripherals(withIdentifiers: [uuid!]) as [CBPeripheral]
    if data.count > 0 {
      _periphEthCard = data[0]
      _periphEthCard?.delegate = self
      _centralManager?.connect(_periphEthCard!, options: nil)
    }
    
    /*
    for (name, uuid) in EtherBTAdapter.discoveredPeripherals{
      if  fullName == name{
        let data = _centralManager!.retrievePeripherals(withIdentifiers: [uuid]) as [CBPeripheral]
        if data.count > 0 {
          _periphEthCard = data[0]
        // _periphEthCard = p
          _periphEthCard?.delegate = self
          _centralManager?.connect(_periphEthCard!, options: nil)
        }
      }
    }
    */
  }
  
  func CardClose() {
    if(_periphEthCard != nil){
      scanLeDevice(false)
      _centralManager?.cancelPeripheralConnection(_periphEthCard!)
      CardEventListener?.onCardClosedSucess(resultCode: EtherError.ETH_SUCCESS)
    }
  }
  
  
  func SetCardEventListener(listener: CardListener) {
    self.CardEventListener = listener
  }
  
  func SetDiscoverServiceEventListener(listener: DiscoverServiceListener) {
    self.DiscoverServiceEventListener = listener
  }
  func SetAdapterEventListener(listener: AdapterListener) {
    self.AdapterEventListener = listener
  }
  
  
  // MARK: - Other functions
  func doStartScan(){
    EtherBTAdapter.discoveredPeripherals.removeAll();
    EtherBTAdapter.discoveredPeripheralInstances.removeAll();
    _foundCards.removeAll(keepingCapacity: false)
    //print("starting scan")
    //print(eth_advserviceCBUUID)
    self._centralManager?.scanForPeripherals(withServices: [CBUUID(string:eth_advServiceUUD)], options: [CBCentralManagerScanOptionAllowDuplicatesKey:_scanAllowDuplicates])
  }
  
  func scanLeDevice(_ enable: Bool) {
    if (enable) {
      // check for timeout
      if _isWithoutTimeout{
        _centralManager?.stopScan()
      }
      doStartScan()
    } else {
      _centralManager?.stopScan()
    }
  }
  
  // we want the ctor to conform to the generic adapter.
  override init() {
    super.init()
  }
  
  func Init(servicePort : UInt8, secsTimeout: Int64, allowDuplicates: Bool, stopScanOnWrite : Bool){
    temp_buffer.removeAll();
    
    if (secsTimeout == -1){
      _scanMSecsTimeout = -1;
    }
    else{
      _scanMSecsTimeout = secsTimeout*1000;
    }
    
    _scanAllowDuplicates = allowDuplicates
    _scanStopScanOnWrite = stopScanOnWrite
    _servicePort = servicePort
    _scanStopScanOnWrite = stopScanOnWrite;
    // STEP 1: create a concurrent background queue for the central
    let centralQueue: DispatchQueue = DispatchQueue(label: "com.ethernom.centralMsgQueue", attributes: .concurrent)
    // STEP 2: create a central to scan for, connect to,
    // manage, and collect data from peripherals
    _centralManager = CBCentralManager(delegate: self, queue: centralQueue)
    if(servicePort != _downloader_servicePort) {
        eth_advServiceUUD = "19490016-5537-4f5e-99ca-290f4fbff142";
    }else {
        let portAsHex = String(format:"%02X", servicePort)
        eth_advServiceUUD = "194900" + portAsHex + "-5537-4f5e-99ca-290f4fbff142"
    }
  }
  
  func Init_DFU(servicePort : String, secsTimeout: Int64, allowDuplicates: Bool, stopScanOnWrite : Bool){
    temp_buffer.removeAll();
    
    if (secsTimeout == -1){
      _scanMSecsTimeout = -1;
    }
    else{
      _scanMSecsTimeout = secsTimeout*1000;
    }
    
    _scanAllowDuplicates = allowDuplicates
    _scanStopScanOnWrite = stopScanOnWrite
    _servicePort = 0
    _scanStopScanOnWrite = stopScanOnWrite;
    // STEP 1: create a concurrent background queue for the central
    let centralQueue: DispatchQueue = DispatchQueue(label: "com.ethernom.centralMsgQueue", attributes: .concurrent)
    // STEP 2: create a central to scan for, connect to,
    // manage, and collect data from peripherals
    _centralManager = CBCentralManager(delegate: self, queue: centralQueue)
    //eth_advServiceUUD = "194900" + portAsHex + "-5537-4f5e-99ca-290f4fbff142"
    
    if(servicePort.count == 4){
      eth_advServiceUUD = "0000" + servicePort + "-0000-1000-8000-00805f9b34fb"
    }
  }
  
  // MARK: - CBCentralManagerDelegate methods
  
  // STEP 3.1: this method is called based on
  // the device's Bluetooth state; we can ONLY
  // scan for peripherals if Bluetooth is .poweredOn
  func centralManagerDidUpdateState(_ central: CBCentralManager) {
    
    switch central.state {
      
    case .unknown:
      //print("Bluetooth status is UNKNOWN")
      break;
    case .resetting:
      //print("Bluetooth status is RESETTING")
      break;
    case .unsupported:
      //print("Bluetooth status is UNSUPPORTED")
      break;
    case .unauthorized:
      //print("Bluetooth status is UNAUTHORIZED")
      break;
    case .poweredOff:
      //print("Bluetooth status is POWERED OFF")
        isPoweredOn = false;
        didModifyServices = false;
      AdapterEventListener?.onAdapterOpenSuccess(resultCode: EtherError.ETH_ADAPTER_NOT_FOUND)
      break;
    case .poweredOn:
      //print("Bluetooth status is POWERED on")
        isPoweredOn = true;
        didModifyServices = false;
      AdapterEventListener?.onAdapterOpenSuccess(resultCode: EtherError.ETH_SUCCESS)
      break;
    } // END switch
    
    // if timeout
    if _isWithoutTimeout {
      DispatchQueue.main.asyncAfter(deadline: .now() + DispatchTimeInterval.milliseconds(Int(_scanMSecsTimeout))) {
        self._centralManager?.stopScan()
      }
    }
  } // END func centralManagerDidUpdateState
  
  // STEP 4.1: discover what peripheral devices OF INTEREST
  // are available for this app to connect to
  func centralManager(_ central: CBCentralManager, didDiscover peripheral: CBPeripheral, advertisementData: [String : Any], rssi RSSI: NSNumber) {
    
    if(eth_advServiceUUD == "0000FE59-0000-1000-8000-00805f9b34fb"){
      let peripheralID = peripheral.identifier.uuidString
      let deviceName = (advertisementData as NSDictionary).object(forKey: CBAdvertisementDataLocalNameKey) as? String
      
      if(deviceName != nil){
        DiscoverServiceEventListener?.onServiceDiscover(resultCode: EtherError.ETH_SUCCESS, peripheralID: peripheralID, deviceName: deviceName!, dSerialNum: "");
      }
      
    }else{
      if advertisementData[CBAdvertisementDataManufacturerDataKey] == nil { return }
      
      let peripheralID = peripheral.identifier.uuidString
      let deviceName = (advertisementData as NSDictionary).object(forKey: CBAdvertisementDataLocalNameKey) as? String
      let dSerialNum = (advertisementData as NSDictionary).object(forKey: CBAdvertisementDataManufacturerDataKey) as? Data
      
      if(deviceName != nil){
        if (DiscoverServiceEventListener != nil && isPoweredOn == true) {
          if(dSerialNum != nil){
            DiscoverServiceEventListener?.onServiceDiscover(resultCode: EtherError.ETH_SUCCESS, peripheralID: peripheralID, deviceName: deviceName!, dSerialNum: dSerialNum!.hexDescription);
          }else{
              DiscoverServiceEventListener?.onServiceDiscover(resultCode: EtherError.ETH_SUCCESS, peripheralID: peripheralID, deviceName: deviceName!, dSerialNum: "");
          }
        }
      }
    }
  }
    
  // STEP 7: "Invoked when a connection is successfully created with a peripheral."
  // we can only move forwards when we know the connection
  // to the peripheral succeeded
  func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {
    //print("connected to periph!")
    
    // peripheral.discoverServices(<#T##serviceUUIDs: [CBUUID]?##[CBUUID]?#>)
    // STEP 8: look for services of interest on peripheral
    peripheral.discoverServices([ETH_serviceUUID])

  } // END func centralManager(... didConnect peripheral
      
  public func centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) {
      //print("[ERROR] Could not connect to peripheral \(peripheral.identifier.uuidString) error: \(error!.localizedDescription)")
  }
  
  //
  // STEP 15: when a peripheral disconnects, take
  // use-case-appropriate action
  func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?)
  {
    decodePeripheralState(peripheralState: peripheral.state);
    //print("Disconnected!")
    
    //        DispatchQueue.main.async { () -> Void in
    //        }
  } // END func centralManager(... didDisconnectPeripheral peripheral
  
  // MARK: - CBPeripheralDelegate methods
  
  func peripheral(_ peripheral: CBPeripheral, didDiscoverServices error: Error?)
  {
    for service in peripheral.services! {
      //print("Service: \(service)")
      //print(service.uuid)
      //print (ETH_serviceUUID)
      if service.uuid == ETH_serviceUUID {
        // STEP 9: look for characteristics of interest
        // within services of interest
        peripheral.discoverCharacteristics(nil, for: service)
      }
    }
  } // END func peripheral(... didDiscoverServices
  
  // STEP 10: confirm we've discovered characteristics
  // of interest within services of interest
  func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?)
  {
    for characteristic in service.characteristics! {
      //print(characteristic)
      //print(ETH_characteristicUUID)

      if characteristic.uuid == ETH_characteristicUUID {
        _ethCharacteristic = characteristic
        _periphEthCard?.setNotifyValue(true, for: _ethCharacteristic!)
        if(didModifyServices == false){
          CardEventListener?.onCardOpenSuccess(resultCode: EtherError.ETH_SUCCESS)
        }else{
          if CardEventListener != nil{
            //print("RECEIVES: ");
            //print(value);
            CardEventListener?.onReadFromCardFail(resultCode: EtherError.ETH_FAIL, hwSpecificError: 0)
          }
        }
        didModifyServices = false;
      }
    }// END for
  }// END func peripheral(... didDiscoverCharacteristicsFor service
  
  func peripheral(_ peripheral: CBPeripheral, didWriteValueFor characteristic: CBCharacteristic, error: Error?){
    if characteristic.uuid == ETH_characteristicUUID {
      if error != nil {
        //print ("did write value error "+error.debugDescription)
      }
      else{
        //print("Characteristic written")
      }
    }
  }// END func peripheral(... didWriteValueFor characteristic
  
  func peripheral(_ peripheral: CBPeripheral, didUpdateValueFor characteristic: CBCharacteristic, error: Error?) {
    if characteristic.uuid == ETH_characteristicUUID {
      let buffer = [UInt8](characteristic.value!)
         handle_receives_packet(value: buffer);
    }
  } // END func peripheral(... didUpdateValueFor characteristic
  
  func peripheral(_ peripheral: CBPeripheral, didModifyServices invalidatedServices: [CBService]){
    print("Did modify...")
    temp_buffer.removeAll();
    didModifyServices = true;
    peripheral.discoverServices([ETH_serviceUUID])
  } // END func peripheral(... didModifyServices characteristic
  
  // Handle packet when receiving...
  func handle_receives_packet(value: [UInt8]){
    if(temp_buffer.count == 0){
      let len:Int32 = get_payload_length(LSB: value[4], MSB: value[5]);
      if(len == (value.count-8)){
        if _writeCallback != nil{
            // the call itself may setup another write.. save off the var
            let  _tempWriteCallback = _writeCallback
            _writeCallback = nil
            _tempWriteCallback!(value)
          }
          else{
              on_card_read_success(final_value: value);
        }
        temp_buffer.removeAll();
      }else{
        print("Doesn't match, writing to temp buffer...");
        for byte in value{ temp_buffer.append(byte) }
      }
      
    }else{
      print("Concat to temp buffer first...");
      for byte in value{ temp_buffer.append(byte) }
      
      let initial_len:Int32 = get_payload_length(LSB: temp_buffer[4], MSB: temp_buffer[5]);
      if(initial_len == (temp_buffer.count-8)){
        if _writeCallback != nil{
            // the call itself may setup another write.. save off the var
            let  _tempWriteCallback = _writeCallback
            _writeCallback = nil
            _tempWriteCallback!(temp_buffer)
          }
          else{
              on_card_read_success(final_value: temp_buffer);
        }
        temp_buffer.removeAll();
      }
    }
  }
  
  func get_payload_length(LSB: UInt8, MSB: UInt8) -> Int32 {
    var len:Int32 = Int32(MSB) * 256 + Int32(LSB & 0xFF);
    if len < 0 { len = len & 0xFFFF; }
    return len
  }
  
  func on_card_read_success(final_value: [UInt8]){
    if CardEventListener != nil{
      //print("RECEIVES: ");
      //print(final_value);
        CardEventListener?.onReadFromCardSuccess(resultCode: EtherError.ETH_SUCCESS, buffer: final_value);
    }
  }
  
  // MARK: - Utilities
  
  func decodePeripheralState(peripheralState: CBPeripheralState) {
    
    switch peripheralState {
    case .disconnected:
      //print("Peripheral state: disconnected")
      if CardEventListener != nil{
        CardEventListener?.onCardConnectionDropped(resultCode: EtherError.ETH_SUCCESS)
      }
      break;
    case .connected:
      //print("Peripheral state: connected")
      break;
    case .connecting:
      //print("Peripheral state: connecting")
      break;
    case .disconnecting:
      //print("Peripheral state: disconnecting")
      break;
    }
    
  } // END func decodePeripheralState(peripheralState
  
  func WriteToCard(buffer: [UInt8]) {
    if(buffer.count > maxByteSize){
      let length: Int = buffer.count;
        var offset: Int = 0;
        repeat{
          let thisChunkSize: Int = length - offset > maxByteSize ? maxByteSize : length - offset;
          var chunk = [UInt8]()
          let range: Int = offset + thisChunkSize;
          for i in offset...(range-1){
            chunk.append(buffer[i]);
          }
          
          offset += thisChunkSize;
          Thread.sleep(forTimeInterval: 0.01)
          doWrite_withoutResponse(buffer: chunk);
        }while(offset < length);
    }else{
        doWrite(buffer: buffer);
    }
    
    /*
    let dp = Data(buffer)
    
    print("write command data to card")
  // print(dp.hexEncodedString())
    
    _periphEthCard?.writeValue(dp, for: _ethCharacteristic!, type: .withResponse)
    */
  }
  
  func doWrite(buffer: [UInt8]) {
    let dp = Data(buffer)
    //print("write command data to card")
    //print(dp.hexEncodedString());
    if(_ethCharacteristic != nil){
        _periphEthCard?.writeValue(dp, for: _ethCharacteristic!, type: .withResponse)
    }
  }
  
  func doWrite_withoutResponse(buffer: [UInt8]) {
    let dp = Data(buffer)
    //print(dp.count);
    //print(dp.hexEncodedString());
    if(_ethCharacteristic != nil){
        _periphEthCard?.writeValue(dp, for: _ethCharacteristic!, type: .withoutResponse)
    }
  }
  
  func cancelRequest(){
    if(_periphEthCard != nil){
      _centralManager?.cancelPeripheralConnection(_periphEthCard!)
    }
    _centralManager?.stopScan()
  }
  
// **************** new encryption
  //*******************************************************************
   //Password Manager transport protocol
   //*******************************************************************
  
  func getUInt8Payload( data : [UInt8])-> [UInt8]{
     var payload = [UInt8]()
     if data.count == 0 {
       payload.append(UInt8(0));
     } else {
       payload = payload + data
     }
     return payload
   }
  
  // fully encrypted
  func computeChecksum(packet:[UInt8])->UInt8{
     var xorValue = packet[0];
      
      // xor the packet header for checksum
      var i = 0
      for c in packet {
        if i > 0 {
          xorValue = xorValue ^ c
        }
        i += 1
      }
     return xorValue
   }
  func MakeTransportHeader(srcport : UInt8, destprt : UInt8, control : UInt8, interface : UInt8, payloadLength : UInt16, protocol : UInt8)-> [UInt8]{
    var packet = [UInt8]()
    packet.append(srcport)
    packet.append(destprt)
    packet.append(control)
    packet.append(interface)
    let uInt8Value0 = UInt8(payloadLength & 0x00ff)
    let uInt8Value1 = UInt8(payloadLength >> 8)
    packet.append(uInt8Value0)
    packet.append(uInt8Value1)
   
    packet.append(INT8NULL)
    packet.append(computeChecksum(packet: packet));
    return packet
  }
    
  //*******************************************************************
  //Password Manager transport protocol
  //*******************************************************************
  func getInitedPacket(appPort:UInt8, payloadLength: UInt16, hasEncHeader: Bool) -> [UInt8]{
   let encPayloadLength = payloadLength + 16
   return MakeTransportHeader(srcport: _servicePort | 0x80, destprt: _servicePort, control: hasEncHeader ? 0x80 : 0, interface: TInterface.BLE.rawValue, payloadLength: encPayloadLength,protocol: INT8NULL)
  }

  func composeBLEPacket(cmd : UInt8,  data : [String], encHeader : EtherEncHeader?) -> [UInt8]{
     // Construct payload as series of delimited strings
     var payload = [UInt8]()
     
     payload.append(cmd);
     if data.count == 0 {
       payload.append(UInt8(0));
     } else {
       var i = 0;
       for s in data{
         let array: [UInt8] = Array(s.utf8)
         for c in array{
           payload.append(c);
         }
         if i < data.count - 1 {
           payload.append(EtherTransportProtocol.DELIMITER);
         }
         i += 1
       }
       payload.append(UInt8(0));
     }
     
     // stuff the payload length in the Enc header
    //print(_servicePort)
     var packetHeader = getInitedPacket(appPort : PSD_MGR_PORT, payloadLength: UInt16(payload.count), hasEncHeader: (encHeader != nil))
     if encHeader != nil{
       encHeader?.SetPayloadLength(len: UInt16(payload.count))
       let epacket = encHeader?.GetHeaderBuffer()
       packetHeader += epacket!
     }
     packetHeader += payload;
     return packetHeader;
   }
  
  func composeBLEPacket(cmd : UInt8, data : [UInt8], encHeader : EtherEncHeader?) -> [UInt8]{
     let payload = getUInt8Payload(data: data)
     print("compose payload:")
     print(payload.hexaSpaced)
    var packetHeader = getInitedPacket(appPort : cmd, payloadLength: UInt16(payload.count), hasEncHeader: (encHeader != nil))
     if encHeader != nil{
       encHeader?.SetPayloadLength(len: UInt16(payload.count))
       let epacket = encHeader?.GetHeaderBuffer()
       packetHeader += epacket!
     }
     packetHeader += payload;
     print("compose return:")
     print(packetHeader.hexaSpaced)
     return packetHeader;
  }
  
  
  // this is used by start encryption and has an empty encryption header
  func WriteDataToCardHasEncryption(data : [UInt8], writeCallback: @escaping ([UInt8]) -> Void) {
    _writeCallback = writeCallback
    let payload = getUInt8Payload( data: data)
    var packet = MakeTransportHeader(srcport: _servicePort | 0x80, destprt: _servicePort, control: 0x80, interface: TInterface.BLE.rawValue, payloadLength: UInt16(payload.count),protocol: INT8NULL)
    packet += payload;
//    let packet = composeBLEPacketRaw(data : data)
    //print (packet);
    //WriteDataToCardRaw(data: packet)
    WriteToCard(buffer: packet);
  }

  func WriteDataToCardRaw( data : [UInt8]) {
    let dp = Data(data)
    _periphEthCard?.writeValue(dp, for: _ethCharacteristic!, type: .withResponse)
  }
  
  func WriteDataToCard(cmd : UInt8, data : [UInt8], encHeader: EtherEncHeader, writeCallback: @escaping ([UInt8]) -> Void) {
    _writeCallback = writeCallback
    let packet = composeBLEPacket(cmd : cmd, data : data, encHeader:encHeader)
   //print("array of data outbound")
   //print(packet);
   //print (packet.hexaSpaced)
   //WriteDataToCardRaw(data: packet)
    WriteToCard(buffer: packet);
  }
  
 func WriteDataToCard(cmd : UInt8,  data : [String], encHeader: EtherEncHeader, writeCallback: @escaping ([UInt8]) -> Void) {
     let packet = composeBLEPacket(cmd: cmd, data : data, encHeader: encHeader)
     print("array of string data outbound")
     print(packet);
     //WriteDataToCardRaw(data: packet);
     WriteToCard(buffer: packet);
   }
  
  func fireReadListener(clearPacket: [UInt8]){
    
  }
  
  func WriteDataToCardEncrypted(appPort : UInt8, EncHeaderAndData : [UInt8], writeCallback: @escaping ([UInt8]) -> Void) {
    _writeCallback = writeCallback
    print("encrypted array of data outbound")
    var packet = getInitedPacket(appPort : appPort, payloadLength: UInt16(EncHeaderAndData.count - EtherTransportProtocol.ETH_BLE_ENC_HEADER_SIZE), hasEncHeader: true)
    packet += EncHeaderAndData;
    print(packet)
    print(packet.count)
    print(packet.hexaSpaced)
    //WriteDataToCardRaw(data:packet)
    WriteToCard(buffer: packet);
  }
}


