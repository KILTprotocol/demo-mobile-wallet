//
//  EtherAPIManager.m
//  ethernom-api
//
//  Created by Fred Covely on 10/23/19.
//  Copyright Â© 2019 admin. All rights reserved.
//
// there needs to be obj c stubs here that call swift

#import "EtherAPIManager.h"

@implementation AdapterListener {
}
- (void)onAdapterOpenFailWithResultCode:(NSInteger)resultCode hwSpecificError:(NSInteger)hwSpecificError {
  //NSLog(@"foobar");
}

- (void)onAdapterOpenSuccessWithResultCode:(NSInteger)resultCode {
  NSNumber * nsn = [NSNumber numberWithInteger:(NSInteger)resultCode];
  reactCallback(@[nsn,etherInstanceId]);
}

@end

@implementation UnSolicitedEventListener
{
}
- (void)onUnsolicitedEventWithResultCode:(NSInteger)resultCode payload:(NSArray<NSNumber *> * _Nonnull)payload {
  NSNumber * nsn = [NSNumber numberWithInteger:(NSInteger)resultCode];
  NSString * s = [_eapi parseToOutputJSONWithPayload:payload outputJSONDef:outPutJSONDef];
  //NSLog(@"firing event to JS");
  //NSLog(_eventName);
  [_owner FireEvent:_eventName body:@{@"resultCode":nsn, @"msgJSON":s}];
}

@end

@implementation CardCloseListener
{
}

- (void)onCardCloseFailWithResultCode:(NSInteger)resultCode hwSpecificError:(NSInteger)hwSpecificError {
  //NSLog(@"onCardCloseFailWithResultCode");
  NSNumber * nsn = [NSNumber numberWithInteger:(NSInteger)resultCode];
  NSNumber * hwN = [NSNumber numberWithInteger:(NSInteger)hwSpecificError];
  reactCallback(@[nsn, hwN]);
}

- (void)onCardCloseSuccessWithResultCode:(NSInteger)resultCode {
  //NSLog(@"onCardCloseSuccessWithResultCode");
  NSNumber * nsn = [NSNumber numberWithInteger:(NSInteger)resultCode];
  reactCallback(@[nsn]);
}

@end

@implementation SelectListener
{
}
- (void)onDisconnectWithResultCode:(NSInteger)resultCode hwSpecificError:(NSInteger)hwSpecificError {
  //NSLog(@"onDisconnectWithResultCode");
  NSNumber * nsn = [NSNumber numberWithInteger:(NSInteger)resultCode];
  NSNumber * hwN = [NSNumber numberWithInteger:(NSInteger)hwSpecificError];
  reactCallback(@[nsn, hwN]);
}

- (void)onSelectFailWithResultCode:(NSInteger)resultCode hwSpecificError:(NSInteger)hwSpecificError {
  NSNumber * nsn = [NSNumber numberWithInteger:(NSInteger)resultCode];
  NSNumber * hwN = [NSNumber numberWithInteger:(NSInteger)hwSpecificError];
  reactCallback(@[nsn, hwN]);
}

- (void)onSelectSuccessWithResultCode:(NSInteger)resultCode {
  NSNumber * nsn = [NSNumber numberWithInteger:(NSInteger)resultCode];
  reactCallback(@[nsn]);
}

@end

@implementation DiscoverServiceListener
{
  
}

- (void)onServiceDiscoverEndWithResultCode:(NSInteger)resultCode {
  //NSLog(@"onServiceDiscoverEndWithResultCode");
  NSNumber * nsn = [NSNumber numberWithInteger:(NSInteger)resultCode];
  reactCallback(@[nsn]);
}

- (void)onServiceDiscoverFailWithResultCode:(NSInteger)resultCode hwSpecificError:(NSInteger)hwSpecificError {
  //NSLog(@"onServiceDiscoverFailWithResultCode");
  NSNumber * nsn = [NSNumber numberWithInteger:(NSInteger)resultCode];
  NSNumber * hwN = [NSNumber numberWithInteger:(NSInteger)hwSpecificError];
  reactCallback(@[nsn, hwN]);
}

- (void)onServiceDiscoverWithResultCode:(NSInteger)resultCode peripheralID:(NSString * _Nonnull)peripheralID deviceName:(NSString * _Nonnull)deviceName dSerialNum:(NSString * _Nonnull)dSerialNum{
  NSNumber * nsn = [NSNumber numberWithInteger:(NSInteger)resultCode];
  //NSLog(@"onServiceDiscoverWithResultCode FIRING TO JS");
  //NSLog(deviceName);
  [_owner FireEvent:_eventName body:@{@"resultCode":nsn, @"peripheralID": peripheralID, @"deviceName":deviceName, @"dSerialNum":dSerialNum}];
}
@end
@implementation ConnectionListener
{
  
}
- (void)onConnectionDroppedWithResultCode:(NSInteger)resultCode {
  //NSLog(@"onConnectionDroppedWithResultCode");
  NSNumber * nsn = [NSNumber numberWithInteger:(NSInteger)resultCode];
  //NSLog(@"firing event to JS");
  //NSLog(_eventName);
  [_owner FireEvent:_eventName body:@{@"resultCode":nsn}];
}
@end

@implementation EncConnectionListener
{
  
}
- (void)onSecureConnectionEstablishedWithResultCode:(NSInteger)resultCode {
  NSLog(@"onSecureConnectionEstablishedWithResultcode");
  NSNumber * nsn = [NSNumber numberWithInteger:(NSInteger)resultCode];
  //NSLog(@"firing event to JS");
  //NSLog(_eventName);
  reactCallback(@[nsn]);
}

@end


@implementation ReadListener
{
 
}

- (void)onReadFailWithResultCode:(NSInteger)resultCode hwSpecificError:(NSInteger)hwSpecificError {
  NSLog(@"foobar");
}

- (void)onReadSuccessWithResultCode:(NSInteger)resultCode payload:(NSArray<NSNumber *> * _Nonnull)payload {
  //NSLog(@"read success calling back to js");
  NSString * s = [_eapi parseToOutputJSONWithPayload:payload outputJSONDef:outPutJSONDef];
  NSNumber * nsn = [NSNumber numberWithInteger:(NSInteger)resultCode];
  reactCallback(@[nsn,s]);
  [_eapi ClearReadListener];
}

@end

@implementation EtherAPIManager
//[_owner sendEventWithName:_eventName body:@{@"resultCode":nsn, @"deviceId": deviceID, @"deviceName":deviceName}];

- (void)FireEvent:(NSString *)eventName body:(id)body{
  //NSLog(@"FireEvent");

  [self sendEventWithName:eventName body:body];
  /*if(hasListeners){
    NSLog(@"FireEvent has listeners");
    [self sendEventWithName:eventName body:body];
  }
  else
    NSLog(@"FireEvent no listeners");*/
}


- (NSArray<NSString *> *)supportedEvents
{
  return listenerNames;
}

-(void)startObserving {
  //NSLog(@"start observing");
  hasListeners = YES;
}

// Will be called when this module's last listener is removed, or on dealloc.
-(void)stopObserving {
  //NSLog(@"stop observing");
  hasListeners = NO;
}
// To export a module named EtherAPIManager
RCT_EXPORT_MODULE();

//  func DiscoverDevices(discoverServiceListener: DiscoverServiceListener) {

//RCT_EXPORT_METHOD(_DiscoverDevices:(NSInteger)instanceHandle eventDiscoverName:(NSString *)eventDiscoverName  callback:(RCTResponseSenderBlock)_callback)
RCT_EXPORT_METHOD(_DiscoverDevices:(NSInteger)instanceHandle eventDiscoverName:(NSString *)eventDiscoverName)
{
  hasListeners = true;
  DiscoverServiceListener * listener = [[DiscoverServiceListener alloc]init];
  // listener->reactCallback  = _callback;
  listener->_eventName = eventDiscoverName;
  listener->_owner = self;
  
  EtherAPI * eapi = [EtherAPI GetEtherApiInstanceWithInstanceId: instanceHandle];
  [eapi DiscoverDevicesWithDiscoverServiceListener:listener];
}

RCT_EXPORT_METHOD(_Select:(NSInteger)instanceHandle deviceID:(NSString *)deviceID deviceName:(NSString *)deviceName  callback:(RCTResponseSenderBlock)_callback)
{
  SelectListener * listener = [[SelectListener alloc]init];
  CardInfo *ci = [CardInfo alloc];
  ci._cardName = deviceName;
  ci._deviceID = deviceID;
  listener->reactCallback  = _callback;
  
  EtherAPI * eapi = [EtherAPI GetEtherApiInstanceWithInstanceId: instanceHandle];
  [eapi SelectWithCardInfo:ci selectListener:listener];
}

// for IOS init IS the constructor as FB provides on a bridge, so we deal directly with the instance handle
// we delegate the management of the etherapi instances to the swift layer
RCT_EXPORT_METHOD(_InitAPI:(NSString *)adapterConnectionString App_ID:(NSInteger)App_ID  secsTimeout:(NSInteger)secsTimeout allowDuplicates:(BOOL)allowDuplicates stopScanOnWrite:(BOOL)stopScanOnWrite callback:(RCTResponseSenderBlock)_callback)
{
  hasListeners = false;
  
  AdapterListener * alistener = [[AdapterListener alloc]init];
  alistener->reactCallback = _callback;
  UInt32 instid = [EtherAPI CreateInstanceWithAdapterConnectionString:adapterConnectionString App_ID:App_ID secsTimeout:secsTimeout allowDuplicates:allowDuplicates stopScanOnWrite:stopScanOnWrite adapterListener:alistener];
  // listener->reactCallback  = _callback;
  instID =[NSNumber numberWithInt:instid];
  if (listenerNames == nil)
    listenerNames = [NSMutableArray array];
  NSString *myString = [instID stringValue];
  NSString * onDiscover = [NSString stringWithFormat:@"onDiscoveredDevice%@", myString];
  NSString * onUnsolicited = [NSString stringWithFormat:@"onUnsolicitedEvent%@", myString];
  NSString * onDisconnect = [NSString stringWithFormat:@"onDisconnected%@", myString];
  [listenerNames addObject:onDiscover];
  [listenerNames addObject:onUnsolicited];
  [listenerNames addObject:onDisconnect];

  alistener->etherInstanceId = instID;
}

RCT_EXPORT_METHOD(_InitDFUAPI:(NSString *)adapterConnectionString App_ID:(NSString *)App_ID  secsTimeout:(NSInteger)secsTimeout allowDuplicates:(BOOL)allowDuplicates stopScanOnWrite:(BOOL)stopScanOnWrite callback:(RCTResponseSenderBlock)_callback)
{
  hasListeners = false;

  AdapterListener * alistener = [[AdapterListener alloc]init];
  alistener->reactCallback = _callback;
  UInt32 instid = [EtherAPI CreateDFUInstanceWithAdapterConnectionString:adapterConnectionString App_ID:App_ID secsTimeout:secsTimeout allowDuplicates:allowDuplicates stopScanOnWrite:stopScanOnWrite adapterListener:alistener];
  // listener->reactCallback  = _callback;
  instID =[NSNumber numberWithInt:instid];
  if (listenerNames == nil)
    listenerNames = [NSMutableArray array];
  NSString *myString = [instID stringValue];
  NSString * onDiscover = [NSString stringWithFormat:@"onDiscoveredDevice%@", myString];
  NSString * onUnsolicited = [NSString stringWithFormat:@"onUnsolicitedEvent%@", myString];
  NSString * onDisconnect = [NSString stringWithFormat:@"onDisconnected%@", myString];
  [listenerNames addObject:onDiscover];
  [listenerNames addObject:onUnsolicited];
  [listenerNames addObject:onDisconnect];

  alistener->etherInstanceId = instID;
}

// This would name the module AwesomeCalendarManager instead
// RCT_EXPORT_MODULE(AwesomeCalendarManager);
RCT_EXPORT_METHOD(_WriteJSON:(NSInteger)instanceHandle json:(NSString *)json outPutJSONDef:(NSString *)outPutJSONDef  callback:(RCTResponseSenderBlock)_callback)
{
  //NSLog(json);

  EtherAPI * eapi = [EtherAPI GetEtherApiInstanceWithInstanceId: instanceHandle];
  BOOL hasTheListener = [eapi hasReadListener];
  ReadListener * listener = nil;
  if(!hasTheListener){
    listener = [[ReadListener alloc]init];
     listener->reactCallback  = _callback;
     listener->outPutJSONDef = outPutJSONDef;
     listener->_eapi = eapi;
  }
  [eapi WriteWithJson:json readListener:listener];
}

// This would name the module AwesomeCalendarManager instead
// RCT_EXPORT_MODULE(AwesomeCalendarManager);
RCT_EXPORT_METHOD(_WriteJSON_DL:(NSInteger)instanceHandle json:(NSString *)json outPutJSONDef:(NSString *)outPutJSONDef  callback:(RCTResponseSenderBlock)_callback)
{
  //NSLog(json);

  EtherAPI * eapi = [EtherAPI GetEtherApiInstanceWithInstanceId: instanceHandle];
  BOOL hasTheListener = [eapi hasReadListener];
  ReadListener * listener = nil;
  if(!hasTheListener){
    listener = [[ReadListener alloc]init];
     listener->reactCallback  = _callback;
     listener->outPutJSONDef = outPutJSONDef;
     listener->_eapi = eapi;
  }
  [eapi Write_DLWithJson:json readListener:listener];
}

// This would name the module AwesomeCalendarManager instead
// RCT_EXPORT_MODULE(AwesomeCalendarManager);
RCT_EXPORT_METHOD(_WriteJSON_Generic:(NSInteger)instanceHandle json:(NSString *)json outPutJSONDef:(NSString *)outPutJSONDef  callback:(RCTResponseSenderBlock)_callback)
{
  //NSLog(json);

  EtherAPI * eapi = [EtherAPI GetEtherApiInstanceWithInstanceId: instanceHandle];
  BOOL hasTheListener = [eapi hasReadListener];
  ReadListener * listener = nil;
  if(!hasTheListener){
    listener = [[ReadListener alloc]init];
     listener->reactCallback  = _callback;
     listener->outPutJSONDef = outPutJSONDef;
     listener->_eapi = eapi;
  }
  [eapi Write_GenericWithJson:json readListener:listener];
}

RCT_EXPORT_METHOD(_StopDiscovery:(NSInteger)instanceHandle)
{
  EtherAPI * eapi = [EtherAPI GetEtherApiInstanceWithInstanceId: instanceHandle];
  [eapi StopDiscovery];
}
RCT_EXPORT_METHOD(_CardClose:(NSInteger)instanceHandle  callback:(RCTResponseSenderBlock)_callback)
{
  CardCloseListener * listener = [[CardCloseListener alloc]init];
  EtherAPI * eapi = [EtherAPI GetEtherApiInstanceWithInstanceId: instanceHandle];
  listener->reactCallback = _callback;
  [eapi CardCloseWithCloseListener:listener];
}

RCT_EXPORT_METHOD(_onCardDisconnected:(NSInteger)instanceHandle eventDisconnectedName:(NSString *)eventDisconnectedName)
{
  hasListeners = true;
  ConnectionListener * listener = [[ConnectionListener alloc]init];
  listener->_owner = self;
  listener->_eventName = eventDisconnectedName;
  EtherAPI * eapi = [EtherAPI GetEtherApiInstanceWithInstanceId: instanceHandle];
  [eapi onCardDisconnectedWithConnectionListener:listener];
}

RCT_EXPORT_METHOD(_SubscribeToUnsolictedEvents:(NSInteger)instanceHandle outPutJSONDef:(NSString *)outPutJSONDef  unSolicitedEventName:(NSString *)unSolicitedEventName)
{
  hasListeners = true;
  UnSolicitedEventListener * listener = [[UnSolicitedEventListener alloc]init];
  listener->_eventName = unSolicitedEventName;
  listener->_owner = self;
  listener->outPutJSONDef = outPutJSONDef;
  EtherAPI * eapi = [EtherAPI GetEtherApiInstanceWithInstanceId: instanceHandle];
  listener->_eapi = eapi;
  [eapi SubscribeToUnsolictedEventsWithUnSolicitedEventListener:listener];
}
RCT_EXPORT_METHOD(_UnSubscribeToUnsolictedEvents:(NSInteger)instanceHandle  unSolicitedEventName:(NSString *)unSolicitedEventName)
{
  EtherAPI * eapi = [EtherAPI GetEtherApiInstanceWithInstanceId: instanceHandle];
  [eapi ClearUnsolicitedEventListener];
}

RCT_EXPORT_METHOD(_DoAppKeyExchange:(NSInteger)instanceHandle   pin:(NSString *)pin  callback:(RCTResponseSenderBlock)_callback)
{
  EncConnectionListener * listener = [[EncConnectionListener alloc]init];
  listener->_owner = self;
  listener->reactCallback  = _callback;
  EtherAPI * eapi = [EtherAPI GetEtherApiInstanceWithInstanceId: instanceHandle];
  [eapi onSecureConnectionWithEncConnectionListener:listener];
  [eapi DoKeyExchangeWithPin:pin];
//  [eapi ]
}

RCT_EXPORT_METHOD(_WriteJSON_Encrypted:(NSInteger)instanceHandle  encrypt:(BOOL)encrypt json:(NSString *)json outPutJSONDef:(NSString *)outPutJSONDef  callback:(RCTResponseSenderBlock)_callback)
{
  //NSLog(json);

  EtherAPI * eapi = [EtherAPI GetEtherApiInstanceWithInstanceId: instanceHandle];
  BOOL hasTheListener = [eapi hasReadListener];
  ReadListener * listener = nil;
  if(!hasTheListener){
    listener = [[ReadListener alloc]init];
     listener->reactCallback  = _callback;
     listener->outPutJSONDef = outPutJSONDef;
     listener->_eapi = eapi;
  }
  [eapi WriteEncryptedWithJson:json doEncrypt:encrypt readListener:listener];
}

@end
