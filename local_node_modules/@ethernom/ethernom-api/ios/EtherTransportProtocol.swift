//
//  EtherTransportProtocol.swift
//  ethernom-api
//
//  Created by admin on 20/10/2019.
//  Copyright Â© 2019 admin. All rights reserved.
//

import Foundation

class EtherTransportProtocol {
    var _servicePort: UInt8
    var _destPort : UInt8
    var _generic_servicePort: UInt8 = 22;
    var _downloader_servicePort: UInt8 = 20;
    var _messageProtocol: TMessageProtocol
    var _interfaceKind: TInterface
    
    var control: UInt8 = 0x0
    
    static var DELIMITER: UInt8 = 31
    static var ETH_BLE_HEADER_SIZE: Int = 8
    static var ETH_BLE_PAYLOAD_HEAD = ETH_BLE_HEADER_SIZE + 1
    static var ETH_BLE_ENC_HEADER_SIZE = 16

    init(servicePort: UInt8, interfaceKind: TInterface, messageProtocol: TMessageProtocol) {
        self._servicePort = servicePort
        self._destPort = servicePort
        self._messageProtocol = messageProtocol
        self._interfaceKind = interfaceKind
    }
  
    public func MakeTransportHeader(srcport : UInt8, destprt : UInt8, control : UInt8, interfaceKind : UInt8, payloadLength : UInt16, protocol : UInt8) -> [UInt8]{
       var packet = [UInt8]()
       packet.append(srcport)
       packet.append(destprt)
       packet.append(control)
       packet.append(interfaceKind)
       let uInt8Value0 = UInt8(payloadLength & 0x00ff)
       let uInt8Value1 = UInt8(payloadLength >> 8)
       packet.append(uInt8Value0)
       packet.append(uInt8Value1)
       packet.append(INT8NULL)
       let checksum = GetTransportMessageCheckSum(packet: packet)
       packet.append(checksum);
       return packet
    }

    func GetServicePort() -> UInt8 {
        return _servicePort
    }
    
    func GetGenericServicePort() -> UInt8 {
        return _generic_servicePort
    }
    
    func GetDLServicePort() -> UInt8 {
        return _downloader_servicePort
    }
  
    func GetApplicationData(data: [UInt8]) throws -> [UInt8] {
        let len = data.count - EtherTransportProtocol.ETH_BLE_HEADER_SIZE
        let start = EtherTransportProtocol.ETH_BLE_HEADER_SIZE;
        
        if start+len <= data.count {
            let sliceArray = data[start...(start+len-1)]
            return Array(sliceArray)
        }
        return []
    }
    
    func GetTransportMessageCheckSum(packet: [UInt8]) -> UInt8 {
        var xorValue = packet[0]
        
        for j in 1..<7 {
            let c = packet[j]
            xorValue = xorValue ^ c
        }
        
        return xorValue
    }
    
    //*******************************************************************
    //*********************APP WRITE**************************************
    //*******************************************************************
    func getTransportHeader(payloadLength: Int) -> [UInt8] {
        let Value0: UInt8 = UInt8(payloadLength & 0x00ff);
        let Value1: UInt8 = UInt8(payloadLength >> 8);
        var packet = [_servicePort | 0x80, _servicePort, control, _interfaceKind.rawValue, Value0, Value1, _messageProtocol.rawValue, 0]
        packet[7] = GetTransportMessageCheckSum(packet: packet)
        return packet
    }
  
    func makeTransportPacket(payload: [UInt8]) -> [UInt8] {
        let packetHeader: [UInt8] = getTransportHeader(payloadLength: payload.count)
        return packetHeader + payload;
    }
  
    // PAYLOADS REQUIRING JUST A COMMAND
    func GetPayload(cmd: Int) -> [UInt8] {
        // Construct payload as series of delimited strings
        let payload: [UInt8] = [
            UInt8(bitPattern: Int8(cmd)),
            UInt8(bitPattern: Int8(0))
        ]
        return makeTransportPacket(payload: payload)
    }
  
    // PAYLOADS WITH A COMMAND BYTE
    func GetPayload(cmd: UInt8, data: [UInt8]) -> [UInt8] {
        return [cmd] + data
    }
  
    // STRING PAYLOAD
    func GetPayload(data: String) -> [UInt8] {
        return GetPayload(data: [UInt8](data.utf8))
    }
  
    // STRING WITH COMMAND BYTE
    func GetPayload(cmd: UInt8, data: String) -> [UInt8] {
        return GetPayload(cmd: cmd, data: [UInt8](data.utf8))
    }
  
    // RAW BYTE PAYLOADS JUST IN CASE
    func GetPayload(data: [UInt8]) -> [UInt8] {
        return makeTransportPacket(payload: data)
    }
  
    // MAJOR USE CASE, PAYLOAD BASED ON A COMMAND AND A STRING ARRAY
    func GetPayload(cmd: UInt8, data: [String]) -> [UInt8] {
        var payload: [UInt8] = [cmd]
        if data.count == 0 {
            payload.append(UInt8(bitPattern: Int8(0)))
        } else {
            var cc: Int = 0
            for item in data {
                payload += [UInt8](item.utf8)
                if cc < data.count - 1 {
                    payload.append(UInt8(bitPattern: Int8(EtherTransportProtocol.DELIMITER)))
                }
                cc += 1
            }
            payload.append(UInt8(bitPattern: Int8(0)))
        }
        return makeTransportPacket(payload: payload)
    }
	
    //*******************************************************************
    //*********************DL WRITE**************************************
    //*******************************************************************
    func getTransportHeader_DL(payloadLength: Int) -> [UInt8] {
      let Value0 = payloadLength & 0x00ff;
      let Value1 = payloadLength >> 8;

      var packet = [
        _downloader_servicePort | 0x80,
        _downloader_servicePort,
        control,
        _interfaceKind.rawValue,
        UInt8(bitPattern: Int8(Value0)),
        UInt8(bitPattern: Int8(Value1)),
        _messageProtocol.rawValue,
        0
      ]
      packet[7] = GetTransportMessageCheckSum(packet: packet)
      return packet
    }
	
    func makeTransportPacket_DL(payload: [UInt8]) -> [UInt8] {
        let packetHeader: [UInt8] = getTransportHeader_DL(payloadLength: payload.count)
        return packetHeader + payload;
    }
	
    func GetPayload_DL(cmd: Int) -> [UInt8] {
        // Construct payload as series of delimited strings
        let payload: [UInt8] = [
            UInt8(bitPattern: Int8(cmd)),
            UInt8(bitPattern: Int8(0))
        ]
        return makeTransportPacket_DL(payload: payload)
    }

    func GetPayload_DL(cmd: UInt8, data: [UInt8]) -> [UInt8] {
        return [cmd] + data
    }
	
    func GetPayload_DL(data: String) -> [UInt8] {
        return GetPayload_DL(data: [UInt8](data.utf8))
    }
	
    func GetPayload_DL(cmd: UInt8, data: String) -> [UInt8] {
        return GetPayload_DL(cmd: cmd, data: [UInt8](data.utf8))
    }
	
    // RAW BYTE PAYLOADS JUST IN CASE
    func GetPayload_DL(data: [UInt8]) -> [UInt8] {
        return makeTransportPacket_DL(payload: data)
    }
    
    func GetPayload_DL(cmd: UInt8, data: [String]) -> [UInt8] {
        var payload: [UInt8] = [cmd]
        if data.count == 0 {
            payload.append(UInt8(bitPattern: Int8(0)))
        } else {
            var cc: Int = 0
            for item in data {
                payload += [UInt8](item.utf8)
                if cc < data.count - 1 {
                    payload.append(UInt8(bitPattern: Int8(EtherTransportProtocol.DELIMITER)))
                }
                cc += 1
            }
            payload.append(UInt8(bitPattern: Int8(0)))
        }
        return makeTransportPacket_DL(payload: payload)
    }
  
    //*******************************************************************
    //****************GENERIC WRITE**************************************
    //*******************************************************************
    func getTransportHeader_Generic(payloadLength: Int) -> [UInt8] {
      let Value0 = payloadLength & 0x00ff;
      let Value1 = payloadLength >> 8;

      var packet = [
        _generic_servicePort | 0x80,
        _generic_servicePort,
        control,
        _interfaceKind.rawValue,
        UInt8(bitPattern: Int8(Value0)),
        UInt8(bitPattern: Int8(Value1)),
        _messageProtocol.rawValue,
        0
      ]
      packet[7] = GetTransportMessageCheckSum(packet: packet)
      return packet
    }
  
    func makeTransportPacket_Generic(payload: [UInt8]) -> [UInt8] {
        let packetHeader: [UInt8] = getTransportHeader_Generic(payloadLength: payload.count)
        return packetHeader + payload;
    }
  
    func GetPayload_Generic(cmd: Int) -> [UInt8] {
        // Construct payload as series of delimited strings
        let payload: [UInt8] = [
            UInt8(bitPattern: Int8(cmd)),
            UInt8(bitPattern: Int8(0))
        ]
        return makeTransportPacket_Generic(payload: payload)
    }

    func GetPayload_Generic(cmd: UInt8, data: [UInt8]) -> [UInt8] {
        return [cmd] + data
    }
  
    func GetPayload_Generic(data: String) -> [UInt8] {
        return GetPayload_Generic(data: [UInt8](data.utf8))
    }
  
    func GetPayload_Generic(cmd: UInt8, data: String) -> [UInt8] {
        return GetPayload_Generic(cmd: cmd, data: [UInt8](data.utf8))
    }
  
    // RAW BYTE PAYLOADS JUST IN CASE
    func GetPayload_Generic(data: [UInt8]) -> [UInt8] {
        return makeTransportPacket_Generic(payload: data)
    }
    
    func GetPayload_Generic(cmd: UInt8, data: [String]) -> [UInt8] {
        var payload: [UInt8] = [cmd]
        if data.count == 0 {
            payload.append(UInt8(bitPattern: Int8(0)))
        } else {
            var cc: Int = 0
            for item in data {
                payload += [UInt8](item.utf8)
                if cc < data.count - 1 {
                    payload.append(UInt8(bitPattern: Int8(EtherTransportProtocol.DELIMITER)))
                }
                cc += 1
            }
            payload.append(UInt8(bitPattern: Int8(0)))
        }
        return makeTransportPacket_Generic(payload: payload)
    }
    
}
