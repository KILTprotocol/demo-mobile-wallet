//
//  EtherSecureSession.swift
//  AutofillExtension
//
//  Created by Fred Covely on 1/17/20.
//  Copyright Â© 2020 Facebook. All rights reserved.
//

import Foundation

// this class does the various security and sessions messages necessary to creata secure live connection to an application in the card
class FrameworkSecureSession{
  var _ecdh = EtherECDH()
  var _aes_eax = Ether_AESEAX()

  var _secureAppSessionEstablished:(EtherErrorValue) -> Void
  var _appMessageReceived:(UInt8,[UInt8]) -> Void
  
  var _host_name = String();
  
  var _pin :String = ""
  
  var _bleClient : EtherBTAdapter?
  var BLEClient : EtherBTAdapter {
    get { return _bleClient!}
  }

  // callbacks recieve EtherError codes
  init(
       bleClient :EtherBTAdapter,
       secureAppSessionEstablished: @escaping (EtherErrorValue) -> Void,
       appMessageReceived: @escaping (UInt8,[UInt8]) -> Void)
  {
    _secureAppSessionEstablished = secureAppSessionEstablished
    _appMessageReceived = appMessageReceived

    _bleClient = bleClient
  }
  

  func DoKeyExchange(pin : String, cmd : UInt8){
     _pin = pin
      print("DoKeyExchange")
     _aes_eax.GenerateKeyPair()
     var payload = [UInt8]()
     payload.append(contentsOf: _aes_eax.GetPublicKeyForCard())
     
     let encHeader = EtherEncHeader( cmd: APP_H2C_KEY_EXCHANGE, status:  0, length: UInt16(TRANSPORT_PLUS_ENC_HEADER_SIZE), sequence: _aes_eax.GetNextSequence())
    self._bleClient?.WriteDataToCard(cmd: cmd, data: payload, encHeader:encHeader, writeCallback: { (tvalue) in
       let (encHeader, _, appPayload) = ParseEncryptedHeader(payload: tvalue)
       if (encHeader[0] == APP_C2H_KEY_EXCHANGE){
         print("public key from card set")
         self._aes_eax.SetCardPublicKey(cardPublicKeyBytes: appPayload)
         self._aes_eax.GenerateSessionKeyFromSecret(pin: self._pin)
         self.doStartEncryptionWithCard()
       }
       else{
         print("Invalid command");
       }
     })
   }
  
  func doStartEncryptionWithCard(){
    // generate a random sequence
    _aes_eax.InitializeRandomSequence()
    let encHeader = EtherEncHeader( cmd: APP_H2C_ENCRYPT_START, status:  0, length: 0, sequence: _aes_eax.GetNextSequence())
    let data = encHeader.GetHeaderBuffer()
    self._bleClient?.WriteDataToCardHasEncryption(data: data, writeCallback: { (tvalue) in
    let (encHeader, _, _) = ParseEncryptedHeader(payload: tvalue)
         if (encHeader[0] == APP_C2H_ENCRYPT_START){
          self._secureAppSessionEstablished(EtherError.ETH_SUCCESS)
          //self.cardConnectedCompleteHandler?()
          // at this point we are set for encyrpted messages, the ether_aeseax module handle the heavy lifting from here on in
  //        let val: UInt8 = 0
    //      self._bleClient!.WriteDataToCardEncrypted(cmd: H2C_RQST_GET_NEXT_ACCOUNT_FOR_DISPLAY, AppData: [val])
         }
         else{
           print("Invalid command");
         }
       })
  }
  /********************WriteDataToCard encrypted methods*/
  func getUInt8Payload( data : [UInt8])-> [UInt8]{
    var payload = [UInt8]()
    if data.count == 0 {
      payload.append(UInt8(0));
    } else {
      payload = payload + data
    }
    return payload
  }
  
  
  func dataPacketReceived(value: [UInt8])->Void{
    // decrypt
    // send in just the transport payload (encheader + app payload
    let (encHeader, transportPayload, appPayload) = ParseEncryptedHeader(payload: value)
    print(encHeader.hexa)
    print(transportPayload.hexa)
    print(appPayload.hexa)
    var fullPacket: [UInt8]?
    if (value[2] & UInt8(FLAG_CONTAIN_ENCRYPTION_HDR)) > 0 && (encHeader[0] & UInt8(APP_FLAG_ENCRYPT)>0){
      let DecryptedPacket = _aes_eax.DecryptData(encHeader:Data(encHeader), encAppData: Data(appPayload))
      fullPacket = transportPayload + DecryptedPacket!
    }
    else{
        fullPacket = transportPayload + appPayload
    }
    print(fullPacket!.hexa)
    _bleClient!.on_card_read_success(final_value: fullPacket!)
  }

  func WriteDataToCardEncrypted(doEncrypt:Bool, AppData : [UInt8]) {
      print("encrypted array of data outbound")
      var apppacket = [UInt8]()
      apppacket.append(contentsOf: getUInt8Payload(data: AppData))
      // get the encrypted header prepended to the actual encrypted data
    var epacket:Data?
    
    if doEncrypt{
      epacket = _aes_eax.EncryptData(encPayload: Data(apppacket))
    }
    else{
      epacket = _aes_eax.EmptyEncryptionHeader(payload: Data(apppacket))
    }
    
    _bleClient?.WriteDataToCardEncrypted(appPort:PSD_MGR_PORT, EncHeaderAndData:[UInt8](epacket!),writeCallback: self.dataPacketReceived)
  }
}

