//
//  EtherSecureSession.swift
//  AutofillExtension
//
//  Created by Fred Covely on 1/17/20.
//  Copyright Â© 2020 Facebook. All rights reserved.
//

import Foundation
import KeychainAccess
//host to card


// this class does the various security and sessions messages necessary to creata secure live connection to an application in the card
class EtherSecureSession{
  var _ecdh = EtherECDH()
  var _aes_eax = Ether_AESEAX()

  var _cardConnectionEstablished:(EtherErrorValue) -> Void? // this is for the link/BLE connection
  var _secureCardSessionEstablished:(EtherErrorValue) -> Void?
  var _appLaunched:(EtherErrorValue) -> Void?
  var _secureAppSessionEstablished:(EtherErrorValue) -> Void
  var _appMessageReceived:(UInt8,[UInt8]) -> Void
  
  var _host_name = String();
  
  var _pin :String = ""
  
  var _bleClient : EthBLEClient?
  var BLEClient : EthBLEClient {
    get { return _bleClient!}
  }

  // error code
  var CM_ERR_SUCCESS          = 0x00;
  var CM_ERR_CARD_BUSY        = 0x01;
  var CM_ERR_INVALID_CMD      = 0x02;
  var CM_ERR_APP_NOT_ALLOWED  = 0x04;
  var CM_ERR_INVALID_IMG_ID   = 0x08;
  var CM_ERR_APP_BUSY         = 0x09;
  var CM_ERR_APP_DISCONNECT   = 0x0E;
  
  // callbacks recieve EtherError codes
  init(string_id: String, string_name: String,
       cardConnectionEstablished: @escaping (_ result : Int) -> Void,
       secureCardSessionEstablished: @escaping (EtherErrorValue) -> Void,
       appLaunched : @escaping (EtherErrorValue) -> Void,
       secureAppSessionEstablished: @escaping (EtherErrorValue) -> Void,
       cardDisconnected: @escaping (EtherErrorValue) -> Void,
       appMessageReceived: @escaping (UInt8,[UInt8]) -> Void)
  {

    _cardConnectionEstablished = cardConnectionEstablished  // this is for the link/BLE connection
    _secureCardSessionEstablished = secureCardSessionEstablished
    _appLaunched = appLaunched
    _secureAppSessionEstablished = secureAppSessionEstablished
    _appMessageReceived = appMessageReceived

    _bleClient = EthBLEClient()
    
    // we use all callbacks so no need for command handler
    _bleClient?.initEthBLE( string_id: string_id, string_name: string_name, aex_eax: _aes_eax,
                            cardDisconnected: cardDisconnected,
                            peripheralConnectedHandler: cardConnectionEstablished,
                            readSuccessHandler: dataPacketReceived)
  }
  
  func dataPacketReceived(value: [UInt8]){
    if (value[2] & UInt8(FLAG_CONTAIN_ENCRYPTION_HDR)) > 0{
      // decrypt
      // send in just the transport payload (encheader + app payload
      let (encHeader, transportPayload, appPayload) = ParseEncryptedHeader(payload: value)
      print(encHeader.hexa)
      print(transportPayload.hexa)
      print(appPayload.hexa)
      let DecryptedPacket = _aes_eax.DecryptData(encHeader:Data(encHeader), encAppData: Data(appPayload))
      let vanillaPacket = transportPayload + DecryptedPacket!
      _appMessageReceived(transportPayload[0],[UInt8](vanillaPacket))
    }
    else{
      _appMessageReceived(value[0], value)
    }
  }

  func DoStartCardAuthentication(appID: UInt8){
    var payload = [UInt8]()
    payload.append(CM_INIT_APP_PERM);
    payload.append(INT8NULL);
    payload.append(1);
    payload.append(INT8NULL);
    //     payload.append(PSD_MGR_ID);
    payload.append(appID);

    _bleClient!.WriteDataToCard_Generic(data: payload, writeCallback: { (tvalue) in
    let value = tvalue
    if value[EtherTransportProtocol.ETH_BLE_HEADER_SIZE] != CM_AUTHENTICATE {
        print("Bad DH sequence from card")
      }
     else{
      //    print(value);
          var challenge = Data.init();
          var count = 0;
          for num in value {
            if(count > 11){ challenge.append(num) }
            count+=1;
          }
          DispatchQueue.main.async {
            self.generate_auth_rsp(challenge: challenge);
          }
      }
    })
   }

   //************  CM_INIT_APP_PERM answers from card and we come here to answer the challenge the car sends using our keys from server ***********************/
   //************  if the card answers with CM_ERR_SUCCESS, we callback the main view controlle which call MakeLaunchAppRequest below   ***********************/
   //************  we send in the clear and with no encryption header, sent to AO manager on card   ***********************/
   func generate_auth_rsp(challenge: Data){
     print("challenge");
     print(challenge.hexEncodedString());
     print(_bleClient!.RegisteredSerialNumber);
    
     let keychain = Keychain(service: _bleClient!.RegisteredSerialNumber, accessGroup: "group.com.ethernom.password.manager.mobile")
     let value = try?keychain.get(_bleClient!.RegisteredSerialNumber)
     if(value != nil){
       let string_value = value!
       let json_data = string_value.toJSON() as? [String:AnyObject]
       
       let pubKey = json_data!["pubkey"] as! String
       let privKey = json_data!["pkey"] as! String
             
       let responseBytes = _ecdh.generate_auth_rsp(challenge: challenge, pubKey: pubKey, privKey: privKey)
       _bleClient!.WriteDataToCard_Generic(data: responseBytes!, writeCallback: { (tvalue) in
           let value = tvalue
           print(CM_RSP)
           print(value[EtherTransportProtocol.ETH_BLE_HEADER_SIZE])
           print(value[12])
           switch (value[EtherTransportProtocol.ETH_BLE_HEADER_SIZE]) {
                 case CM_RSP:
                   if(value[12] == self.CM_ERR_SUCCESS){
                     print("Authenticate success!");
                    // we have established a card session,
                    self._secureCardSessionEstablished(EtherError.ETH_SUCCESS)
//                     self.readyHandler?(); // calls back to main page which sends a launchs
                   }else{
                     print("Auth fails");
                     self._bleClient?.cancelRequest()
                    self._secureCardSessionEstablished(EtherError.ETH_CARD_AUTH_FAIL)
                   }
                   break;
               
                 default:
                   print("Invalid command");
                   self._bleClient?.cancelRequest()
                   self._secureCardSessionEstablished(EtherError.ETH_FAIL)
                   break;
             }
       })
     }
   }
   
   
   //************  REQUEST APP LAUNCH AND IF IT SUCCEEDS, INIT PWD MANAGER BELOW, sent to AO manager on card, cleartext ***********************/
  func RequestAppLaunch(host_name: String, appID: UInt8){
     var payload = [UInt8]()
     payload.append(CM_LAUNCH_APP);
     payload.append(INT8NULL);
     payload.append(1);
     payload.append(INT8NULL);
     //payload.append(PSD_MGR_PORT);
     payload.append(appID);

     _host_name = host_name;
     
    _bleClient?.WriteDataToCard_Generic(data: payload, writeCallback: { (tvalue) in let value = tvalue
      print(value[12]);
      if(value[12] == self.CM_ERR_SUCCESS){
        DispatchQueue.main.async {
          if(self._bleClient?.AutoReconnect  == false && self._bleClient?.CancelRequest == false){
            self._appLaunched(EtherError.ETH_SUCCESS)
          }
        }
      }else if(value[12] == self.CM_ERR_APP_BUSY){
        self._bleClient?.AutoReconnect = true;
        self._bleClient?.CancelRequest = false
        self.requestSuspendApp();
        
      }else{
        self._bleClient?.AutoReconnect = false;
        self._bleClient?.CancelRequest = true;
        self.requestSuspendApp();
        self._bleClient?.StopScan();
        
      }
    })
  }

   //************  INIT PWD MANAGER, IF IT SUCCEEDS START KEY EXCHANGE FOR AEAD, sent WITH AN EMPTY ENCRYPTION HEADER, in the clear to pwd manager itself ***********************/
  func requestPwdMgrInit(pin : String){
    _pin = pin
     print("RequestPWdMgrInit")
     let encHeader = EtherEncHeader( cmd: APP_H2C_MSG, status:  0, length: UInt16(TRANSPORT_PLUS_ENC_HEADER_SIZE), sequence: 0)
     self._bleClient?.WriteDataToCard(cmd : H2C_RQST_INIT, data: [_host_name, "000000"], encHeader: encHeader, writeCallback: { (tvalue) in
         let value = tvalue
         print(CM_RSP)
         print(value[EtherTransportProtocol.ETH_BLE_HEADER_SIZE])
         print(value[12])
         self.doKeyExchange()
     })
   }
   
   //************  GENERATE A RANDOM KEYPAIR AND SEND THE PUBLIC KEY TO CARD, CARD ACKS BACK WITH ITS OWN PUBLIC KEY FOR AEX_EAX ENCRYPTION ***********************/
   //************  GenerateSessionKeyFromSecret HANDLES THE HEAVY LIFTING, THEN WE NEXT START ENCRYPTION WITH CARD ***********************/
   //************  SENT IN THE CLEAR WITH ENCRYPTION HEADER AND PUBLIC KEY FROM HOST ***********************/
   func doKeyExchange(){
     _aes_eax.GenerateKeyPair()
     var payload = [UInt8]()
     payload.append(contentsOf: _aes_eax.GetPublicKeyForCard())
     
     let encHeader = EtherEncHeader( cmd: APP_H2C_KEY_EXCHANGE, status:  0, length: UInt16(TRANSPORT_PLUS_ENC_HEADER_SIZE), sequence: _aes_eax.GetNextSequence())
     self._bleClient?.WriteDataToCard(data: _aes_eax.GetPublicKeyForCard(), encHeader:encHeader, writeCallback: { (tvalue) in
       let (encHeader, _, appPayload) = ParseEncryptedHeader(payload: tvalue)
       if (encHeader[0] == APP_C2H_KEY_EXCHANGE){
         print("public key from card set")
         self._aes_eax.SetCardPublicKey(cardPublicKeyBytes: appPayload)
        self._aes_eax.GenerateSessionKeyFromSecret(pin: self._pin)
         self.doStartEncryptionWithCard()
       }
       else{
         print("Invalid command");
       }
     })
   }
  
  func doStartEncryptionWithCard(){
    // generate a random sequence
    _aes_eax.InitializeRandomSequence()
    let encHeader = EtherEncHeader( cmd: APP_H2C_ENCRYPT_START, status:  0, length: 0, sequence: _aes_eax.GetNextSequence())
    let data = encHeader.GetHeaderBuffer()
    self._bleClient?.WriteDataToCardHasEncryption(data: data, writeCallback: { (tvalue) in
    let (encHeader, _, _) = ParseEncryptedHeader(payload: tvalue)
         if (encHeader[0] == APP_C2H_ENCRYPT_START){
          self._secureAppSessionEstablished(EtherError.ETH_SUCCESS)
          //self.cardConnectedCompleteHandler?()
          // at this point we are set for encyrpted messages, the ether_aeseax module handle the heavy lifting from here on in
  //        let val: UInt8 = 0
    //      self._bleClient!.WriteDataToCardEncrypted(cmd: H2C_RQST_GET_NEXT_ACCOUNT_FOR_DISPLAY, AppData: [val])
         }
         else{
           print("Invalid command");
         }
       })
  }

  func requestSuspendApp(){
  if(_bleClient!.HasPeripheralConnection){
    if(_bleClient?.AutoReconnect == false){
      _bleClient?.CancelRequest = true;
    }
    var payload = [UInt8]()
    payload.append(CM_SUSPEND_APP)
    payload.append(INT8NULL)
    payload.append(1)
    payload.append(INT8NULL)
    payload.append(INT8NULL)
    
    _bleClient?.WriteDataToCard_Generic(data: payload);
  }else{
    _bleClient?.cancelRequest();
  }
}
  /********************WriteDataToCard encrypted methods*/
  func getUInt8Payload( data : [UInt8])-> [UInt8]{
    var payload = [UInt8]()
    if data.count == 0 {
      payload.append(UInt8(0));
    } else {
      payload = payload + data
    }
    return payload
  }


  // fully encrypted
   func WriteDataToCardEncrypted(cmd : UInt8,  AppData : [String]) {
    print("encrypted array of data outbound")
    let apppacket = _bleClient?.composePayload(cmd: cmd, data: AppData)
    let epacket = _aes_eax.EncryptData(encPayload: Data(apppacket!))
    _bleClient?.WriteDataToCardEncrypted(appPort:PSD_MGR_PORT,  EncHeaderAndData:[UInt8](epacket!))
  }
  
  func WriteDataToCardEncrypted(cmd : UInt8,  AppData : [UInt8]) {
     print("encrypted array of data outbound")
     var apppacket = [UInt8]()
     apppacket.append(cmd)
     apppacket.append(contentsOf: getUInt8Payload(data: AppData))
     // get the encrypted header prepended to the actual encrypted data
     let epacket = _aes_eax.EncryptData(encPayload: Data(apppacket))
    _bleClient?.WriteDataToCardEncrypted(appPort:PSD_MGR_PORT,  EncHeaderAndData:[UInt8](epacket!))
 }
  
}

