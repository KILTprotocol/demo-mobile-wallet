//
//  EtherEncHeader.swift
//  EthernomPasswordManagerMobile
//
//  Created by Fred Covely on 1/12/20.
//  Copyright Â© 2020 Facebook. All rights reserved.
//

import Foundation

let AES_MAC_SIZE      = 8;
let AES_KEY_SIZE      = 16;
let TRANSPORT_PLUS_ENC_HEADER_SIZE : UInt8 =  24;

public class EtherEncHeader {
    // encryption extensions
    static var _encSequence : UInt32 = 0
    var _encCmd : UInt8 = 0
    var _encStatus : UInt8 = 0
    var _encLength : UInt16 = 0 // so this is misnamed, its actually the lenght of the transport header plus the length of the enc header, its really the data offset
    var _encSequence : UInt32 = 0
    var _encMac = [UInt8]()
  
  // end encryption extensions
  init(cmd : UInt8, status : UInt8, length : UInt16, sequence : UInt32) {
    initMac()
    _encCmd = cmd
    _encStatus = status
    _encLength = length
    EtherEncHeader._encSequence = sequence
  }

  init(cmd : UInt8, status : UInt8, length : UInt16, sequence : UInt32, mac:[UInt8]) {
    for i in 0...7{
       _encMac.append(mac[i])
     }
    _encCmd = cmd
    _encStatus = status
    _encLength = length
    EtherEncHeader._encSequence = sequence
  }

  func initMac()->Void{
    _encMac.removeAll()
    for _ in 0...7{
      _encMac.append(0)
    }
  }
  
  func SetPayloadLength(len : UInt16){
    _encLength = len
  }
  
  func SetMac(mac : [UInt8]){
    var i = 0
    _encMac.removeAll()
    for _ in 0...7{
      _encMac.append(mac[i])
      i += 1
    }
  }
  func GetNonce() ->[UInt8]{
    var nonceheader = [UInt8]()
    nonceheader.append(_encCmd)
    nonceheader.append(_encStatus)

    let uInt8Value0 = UInt8(_encLength & 0x00ff)
    let uInt8Value1 = UInt8(_encLength >> 8)
    nonceheader.append(uInt8Value0)
    nonceheader.append(uInt8Value1)

    print("sequence:")
    print(EtherEncHeader._encSequence)
    
    let byte1 = UInt8(EtherEncHeader._encSequence & 0x000000FF)
    let byte2 = UInt8((EtherEncHeader._encSequence & 0x0000FF00) >> 8)
    let byte3 = UInt8((EtherEncHeader._encSequence & 0x00FF0000) >> 16)
    let byte4 = UInt8((EtherEncHeader._encSequence & 0xFF000000) >> 24)
     
    nonceheader.append(byte1)
    nonceheader.append(byte2)
    nonceheader.append(byte3)
    nonceheader.append(byte4)

    let padding = [UInt8](repeating: 0, count: 8)
    nonceheader.append(contentsOf: padding)

    print("nonce: ")
    print(nonceheader.hexa)
    return nonceheader
  }
  
  func GetHeaderBuffer ()->[UInt8]{
    var header = [UInt8]()
    header.append(_encCmd)
    header.append(_encStatus)
   
    let uInt8Value0 = UInt8(_encLength & 0x00ff)
    let uInt8Value1 = UInt8(_encLength >> 8)
    header.append(uInt8Value0)
    header.append(uInt8Value1)

    let byte1 = UInt8(EtherEncHeader._encSequence & 0x000000FF)
    let byte2 = UInt8((EtherEncHeader._encSequence & 0x0000FF00) >> 8)
    let byte3 = UInt8((EtherEncHeader._encSequence & 0x00FF0000) >> 16)
    let byte4 = UInt8((EtherEncHeader._encSequence & 0xFF000000) >> 24)
    
    header.append(byte1)
    header.append(byte2)
    header.append(byte3)
    header.append(byte4)
    
    header.append(contentsOf: _encMac)
    return header
  }
  
  func GetNextHeaderBuffer(cmd : UInt8, status : UInt8, length : UInt16)->[UInt8]{
    _encSequence += 1;
    return GetHeaderBuffer()
  }
}
