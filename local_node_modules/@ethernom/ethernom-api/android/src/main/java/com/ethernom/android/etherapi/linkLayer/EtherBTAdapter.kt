package com.ethernom.android.etherapi.linkLayer

import android.R.string
import android.bluetooth.*
import android.bluetooth.le.*
import android.content.Context
import android.os.Handler
import android.os.ParcelUuid
import android.util.Log
import android.util.Xml
import com.ethernom.android.etherapi.*
import com.ethernom.android.etherapi.EtherError.ETH_FAIL
import com.ethernom.android.etherapi.EtherError.ETH_SUCCESS
import com.ethernom.android.etherapi.Extentions.hexaSpaced
import java.util.*
import kotlin.experimental.and
import kotlin.experimental.or
import kotlin.experimental.xor

class EtherBTAdapter : EtherCommAdapter {
    private var _adapterAddress: String? = null
    private var _context: Context? = null
    override var _scanAllowDuplicates = true
    override var _scanMSecsTimeout = 30000L
    override var _scanStopScanOnWrite = true
    override var _foundCards = ArrayList<CardInfo>()
    override var _cardEventListener: CardListener? = null
    override var _discoverServiceEventListener: DiscoverServiceListener? = null
    override var _adapterEventListener: AdapterListener? = null

    // AO on the card or what a dev would call a service
    private var _servicePort : Byte = 0

    private val _downloader_servicePort = 0x14.toByte()
    private var mBluetoothAdapter: BluetoothAdapter? = null
    private var mHandler: Handler? = null
    private var mLEScanner: BluetoothLeScanner? = null
    private var settings: ScanSettings? = null
    private var filters: MutableList<ScanFilter>? = null
    private var periphEthCard: BluetoothDevice? = null
    private var gatt: BluetoothGatt? = null
    private var ethCharacteristic: BluetoothGattCharacteristic? = null
    private var eth_advServiceUUD: String? = null
    private val maxByteSize = 188
    private var _writeCallback:((ByteArray) -> Unit)? = null
    private var _temp_buffer = ByteArray(0)

    // IETHERCOMADAPTER
    override fun GetInterface(): TInterface {
        return TInterface.BLE
    }

     // these need to set the link layer specific address of the BLE adapter, COM/USB adapter or NFC
// as appropriate to the link layer in question
    override fun GetAdapterAddress(): String {
        return _adapterAddress!!
    }

    override fun SetAdapterAddress(adapterAddress: String) {
        _adapterAddress = adapterAddress
    }

    fun convertFromInteger(i: Int): UUID {
        val MSB = 0x0000000000001000L
        val LSB = -0x7fffff7fa064cb05L
        val value = (i and (-0x1.toLong()).toInt()).toLong()
        return UUID(MSB or (value shl 32), LSB)
    }

    override fun StopDiscovery() {
        scanLeDevice(false)
    }

    override fun Init(servicePort: Byte, secsTimeout: Long, allowDuplicates: Boolean, stopScanOnWrite: Boolean, context: Context) {
        _scanAllowDuplicates = allowDuplicates
        _temp_buffer = ByteArray(0)
        _scanMSecsTimeout = if (secsTimeout == -1L) -1 else secsTimeout * 1000
        _scanStopScanOnWrite = stopScanOnWrite
        mHandler = Handler()
        _context = context
        _servicePort = servicePort
        val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
        mBluetoothAdapter = bluetoothManager.adapter
        eth_advServiceUUD = if (servicePort != _downloader_servicePort.toByte()) {
            "19490016-5537-4f5e-99ca-290f4fbff142"
        } else {
            val portAsHex = String.format("%02x", servicePort)
            "194900$portAsHex-5537-4f5e-99ca-290f4fbff142"
        }
    }

    override fun Init_DFU(UUID: String, secsTimeout: Long, allowDuplicates: Boolean, stopScanOnWrite: Boolean, context: Context){
        _scanAllowDuplicates = allowDuplicates
        _scanMSecsTimeout = if (secsTimeout == -1L) -1 else secsTimeout * 1000
        _scanStopScanOnWrite = stopScanOnWrite
        mHandler = Handler()
        _context = context
        val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
        mBluetoothAdapter = bluetoothManager.adapter
        eth_advServiceUUD = UUID.toLowerCase()
    }

    private fun scanLeDevice(enable: Boolean) {
        if (enable) { // check for timeout
            if (_scanMSecsTimeout != -1L) {
                mHandler!!.postDelayed({
                    mLEScanner!!.stopScan(mScanCallback)

//                    mHandler!!.removeCallbacksAndMessages(null)
                }, _scanMSecsTimeout)
            }
            mLEScanner!!.startScan(filters, settings, mScanCallback)
        } else {
            if (mLEScanner != null) {
                mLEScanner!!.stopScan(mScanCallback)
                mHandler!!.removeCallbacksAndMessages(null)
            }
        }
    }

    override fun Discover() {
        _foundCards.clear()
        mLEScanner = mBluetoothAdapter!!.bluetoothLeScanner
        settings = ScanSettings.Builder()
                .setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY)
                .build()
        filters = ArrayList()
        if (eth_advServiceUUD!!.length > 4) {
            val scanFilter = ScanFilter.Builder()
                    .setServiceUuid(ParcelUuid.fromString(eth_advServiceUUD))
                    .build()
            filters!!.add(scanFilter)
        } else if (eth_advServiceUUD!!.length == 4) {
            val UUID_BASE = "0000XXXX-0000-1000-8000-00805f9b34fb"
            val NEW_UUID_BASE: String = UUID_BASE.replace("XXXX", eth_advServiceUUD!!)
            val scanFilter = ScanFilter.Builder()
                    .setServiceUuid(ParcelUuid.fromString(NEW_UUID_BASE))
                    .build()
            filters!!.add(scanFilter)
        }
        scanLeDevice(true)
    }

    // END IETHERCOMADAPTER
    private val mScanCallback: ScanCallback = object : ScanCallback() {
        override fun onScanResult(callbackType: Int, result: ScanResult) {

            val devName = result.scanRecord!!.deviceName
            if (devName != null && devName.startsWith("ETH!")) {
                if (eth_advServiceUUD!!.length > 4) {
                    if (result.scanRecord!!.manufacturerSpecificData == null) return
                    val mdata = result.scanRecord!!.manufacturerSpecificData
                    for (i in 0 until mdata.size()) {
                        val mfdata = mdata[mdata.keyAt(i)] ?: return
                        val manufacturerData = toUnsignedIntArray(mfdata)
                        var deviceSN = ""
                        for (k in 0 until manufacturerData.size) { //deviceSN += Integer.toHexString(manufacturerData[k]);
                            var tempString = String.format("%02x", manufacturerData[k]);
                            if (tempString.indexOf("ffffff") == 0) {
                                tempString = tempString.substring(6, 8);
                                deviceSN += tempString
                            } else {
                                deviceSN += tempString
                            }
                        }

                        val device = result.device.toString()
                        if (!_scanAllowDuplicates) { // see if we already have this card
                            for (j in 0 until _foundCards.count()) {
                                val ci = _foundCards[j]
                                if (devName.compareTo(ci.GetCardName()) == 0 && device.compareTo(ci.GetDeviceID()) == 0) return  //already have it
                            }
                            // add to
                            _foundCards.add(CardInfo(devName, device, deviceSN))
                        }
                        if (_discoverServiceEventListener != null) {
                            _discoverServiceEventListener!!.onServiceDiscover(ETH_SUCCESS, device, devName, deviceSN)
                        }
                    }
                } else if (eth_advServiceUUD!!.length == 4) {
                    val device = result.device.toString()
                    if (!_scanAllowDuplicates) { // see if we already have this card
                        for (j in 0 until _foundCards.count()) {
                            val ci = _foundCards[j]
                            if (devName.compareTo(ci.GetCardName()) == 0 && device.compareTo(ci.GetDeviceID()) == 0) return  //already have it
                        }
                        // add to
                        _foundCards.add(CardInfo(devName, device, ""))
                    }
                    if (_discoverServiceEventListener != null) {
                        _discoverServiceEventListener!!.onServiceDiscover(ETH_SUCCESS, device, devName, "")
                    }
                }
            }
        }

        private fun toUnsignedIntArray(barray: ByteArray): IntArray {
            val ret = IntArray(barray.size)
            for (i in barray.indices) {
                //Log.i("TEST2", barray[i].toUInt().toString());
                ret[i] = (barray[i] and 0xff.toByte()).toInt(); // Range 0 to 255, not -128 to 128
            }
            return ret
        }

        override fun onBatchScanResults(results: List<ScanResult>) {
            for (sr in results) {
                Log.i("ETHERBTADAPTER", sr.toString())
            }
        }

        override fun onScanFailed(errorCode: Int) {
            if (_cardEventListener != null) _cardEventListener!!.onCardOpenFail(EtherError.ERR_ETH_CARDSCAN_FAILED, errorCode)
        }
    }

    override fun CardOpen(cardInfo: CardInfo) {
        if (mLEScanner != null) mLEScanner!!.stopScan(mScanCallback)
        periphEthCard = mBluetoothAdapter!!.getRemoteDevice(cardInfo.GetDeviceID())
        gatt = periphEthCard!!.connectGatt(_context, false, gattCallback)
    }

    override fun CardClose() {
        scanLeDevice(false)
        if (gatt != null) gatt!!.close()
        if (_cardEventListener != null) _cardEventListener!!.onCardClosedSucess(ETH_SUCCESS)
    }

    var gattCallback: BluetoothGattCallback = object : BluetoothGattCallback() {
        override fun onConnectionStateChange(gatt: BluetoothGatt, status: Int, newState: Int) {
            if (newState == BluetoothGatt.STATE_CONNECTED) {
                gatt.requestConnectionPriority(BluetoothGatt.CONNECTION_PRIORITY_HIGH);
                try {Thread.sleep(500);} catch (e: InterruptedException){}
                gatt.discoverServices()
            }
            if (newState == BluetoothGatt.STATE_DISCONNECTED) {
                if (_cardEventListener != null) { //CardEventListener.onCardConnectionDropped(status);
                    _cardEventListener!!.onCardConnectionDropped(ETH_SUCCESS)
                    gatt.close()
                }
            }
        }

        override fun onServicesDiscovered(gatt: BluetoothGatt, status: Int) {
            ethCharacteristic = gatt.getService(ETH_serviceUUID).getCharacteristic(ETH_characteristicUUID)
            val CLIENT_CHARACTERISTIC_CONFIG_UUID = convertFromInteger(0x2902)
            if (ethCharacteristic != null) {
                val descriptor = ethCharacteristic!!.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG_UUID)
                if (descriptor != null) {
                    descriptor.value = BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE
                    gatt.setCharacteristicNotification(ethCharacteristic, true)
                    gatt.writeDescriptor(descriptor)
                }
                //gatt.setCharacterissticNotification(ethCharacteristic, true);
            }
        }

        override fun onDescriptorWrite(gatt: BluetoothGatt, descriptor: BluetoothGattDescriptor, status: Int) {
            if (_cardEventListener != null) {
                Log.i(TAG, "onDescriptorWrite, fire listener")
                if (status == 0)
                    _cardEventListener!!.onCardOpenSuccess(ETH_SUCCESS)
                else
                    _cardEventListener!!.onCardOpenFail(ETH_FAIL, status)
            }
        }

        override fun onCharacteristicWrite(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, status: Int) {
            if (_cardEventListener != null) {
                if (status != 0) {
                    _cardEventListener!!.onWriteToCardFail(ETH_FAIL, status)
                    Log.i(TAG, "oncharacteristicwrite failed write")
                } else {
                    _cardEventListener!!.onWriteToCardSuccess(ETH_SUCCESS)
                    Log.i("EtherBLE", "oncharacteristicwrite success")
                }
            }
        }

        override fun onCharacteristicRead(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic, status: Int) {
            if (status != 0)
                Log.i("EtherBLE", "oncharacteristicread failed write")
            else
                Log.i("EtherBLE", "oncharacteristicread success")
        }

        override fun onCharacteristicChanged(gatt: BluetoothGatt, characteristic: BluetoothGattCharacteristic) {
            val value = characteristic.value
            handle_receives_packet(value)
        }
    }

    fun handle_receives_packet(value: ByteArray){
        if(_temp_buffer.count() == 0){
            val len = get_payload_length(value[4], value[5])
            if(len == (value.count()-8)){
                on_card_read_success(value);
                _temp_buffer = ByteArray(0)
            }else{
                for (byte in value){
                    _temp_buffer += byte
                }
            }

        }else{
            for (byte in value){
                _temp_buffer += byte
            }

            val initial_len = get_payload_length(_temp_buffer[4], _temp_buffer[5])
            if(initial_len == (_temp_buffer.count()-8)){
               on_card_read_success(_temp_buffer);
                _temp_buffer = ByteArray(0)
            }
        }
    }

    fun get_payload_length(LSB: Byte, MSB: Byte) : Int{
        var len : Int = MSB.toInt() * 256 + (LSB and 0xFF.toByte()).toInt();
        if (len < 0)
            len = len and 0xFFFF;
        return len
    }

    public fun on_card_read_success(value: ByteArray){
       if (_writeCallback != null){
            // the call itself may setup another write.. save off the var
            val _tempWriteCallback = _writeCallback
            _writeCallback = null
            _tempWriteCallback?.invoke(value)

        }else if (_cardEventListener != null){
            _cardEventListener!!.onReadFromCardSuccess(
                    resultCode = EtherError.ETH_SUCCESS.toInt(),
                    buffer = value
            )
        }
    }

    // a way to write byte buffers
    override fun WriteToCard(data: ByteArray) {
        if (data.size > maxByteSize) {
            ethCharacteristic!!.writeType = BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE
            val dataLength = data.size
            var count = 0
            var firstMessage = ByteArray(0)
            val splittedMessage: MutableList<ByteArray> = ArrayList()
            while (count < dataLength && dataLength - count > maxByteSize) {
                if (count == 0) {
                    firstMessage = Arrays.copyOfRange(data, count, count + maxByteSize)
                } else {
                    val splitMessage = Arrays.copyOfRange(data, count, count + maxByteSize)
                    splittedMessage.add(splitMessage)
                }
                count += maxByteSize
            }
            if (count < dataLength) { // Other bytes in queue
                val splitMessage = Arrays.copyOfRange(data, count, data.size)
                splittedMessage.add(splitMessage)
            }
            try {
                var writeError = false
                if (!doWrite(firstMessage)) {
                    writeError = true
                    //callback.invoke("Write failed");
                }
                if (!writeError) {
                    Thread.sleep(30)
                    for (message in splittedMessage) {
                        if (!doWrite(message)) {
                            writeError = true
                            //callback.invoke("Write failed");
                            break
                        }
                        Thread.sleep(30)
                    }
                    if (!writeError) { //callback.invoke("Write success");
                    }
                }
            } catch (e: InterruptedException) { //callback.invoke("Write failed");
            }
        } else {
            ethCharacteristic!!.writeType = BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT
            if (!doWrite(data)) { //callback.invoke("Write failed");
            }
        }
    }

    fun computeChecksum(packet:ByteArray) : Byte{
        var xorValue = packet[0];
        var i = 0
        for (c in packet) {
            if (i > 0) {
                xorValue = xorValue xor c
            }
            i += 1
        }
        return xorValue
    }

    fun MakeTransportHeader(srcport : Byte, destprt : Byte, control : Byte, bleinterface : Byte, payloadLength : Int, protocol : Byte): ByteArray{
        var packet = ByteArray(0)
        packet += srcport
        packet += destprt
        packet += control
        packet +=  bleinterface

        val uInt8Value0 = (payloadLength and 0x00ff).toByte()
        val uInt8Value1 = (payloadLength shr 8).toByte()

        packet += uInt8Value0
        packet += uInt8Value1

        packet += INT8NULL
        packet += computeChecksum(packet)
        return packet
    }

    fun getInitedPacket(payloadLength: Int, useEncryption: Boolean) : ByteArray{
        val encPayloadLength = payloadLength + 16
        val srcport = _servicePort or  (0x80).toByte()
        var usenc = 0
        if (useEncryption)
            usenc = 0x80

        return MakeTransportHeader(srcport , _servicePort, usenc.toByte(),  TInterface.BLE.rawValue.toByte(), encPayloadLength,INT8NULL)
    }
    // a way to write byte buffers
    fun getUInt8Payload(data : ByteArray) : ByteArray {
        var payload = ByteArray(0)
        if (data.count() == 0) {
            payload += INT8NULL
        } else {
            payload = payload + data
        }
        return payload
    }

    fun composeBLEPacket(data : ByteArray, encHeader : EtherEncHeader) : ByteArray{
        var payload = getUInt8Payload(data)
        val hasEncHeader = (encHeader != null)
        var packetHeader = getInitedPacket( payload.count(), hasEncHeader)
        if (hasEncHeader){
            encHeader?.SetPayloadLength(payload.count())
            val epacket = encHeader?.GetHeaderBuffer()
            packetHeader += epacket
        }
        packetHeader += payload;
        return packetHeader;
    }


    override fun WriteToCardEnc(data: ByteArray, encHeader : EtherEncHeader, writeCallback : (tvalue: ByteArray)->Unit) {
        if(_writeCallback != null) _writeCallback = null;
        _writeCallback = writeCallback

        val packet = composeBLEPacket(data,  encHeader)
        WriteToCard(packet);
    }

    override fun WriteDataToCardHasEncryption(data: ByteArray, writeCallback: (tvalue: ByteArray) -> Unit) {
        if(_writeCallback != null) _writeCallback = null;
        _writeCallback = writeCallback

        val payload = getUInt8Payload( data)
        val srcport :Byte = _servicePort or  (0x80).toByte()
        var packet = MakeTransportHeader( srcport, _servicePort.toByte(),  0x80.toByte(), TInterface.BLE.rawValue.toByte(), payload.count(),INT8NULL)
        packet += payload;
        WriteToCard(packet);
    }

    fun doWrite(data: ByteArray): Boolean {
        ethCharacteristic!!.value = data
        if (!gatt!!.writeCharacteristic(ethCharacteristic)) {
            return false
        }
        return true
    }

    companion object {
        var TAG = "EtherBTAdapter"
        var ETH_serviceUUID = UUID.fromString("19490001-5537-4F5E-99CA-290F4FBFF142")
        var ETH_characteristicUUID = UUID.fromString("19490002-5537-4F5E-99CA-290F4FBFF142")
    }
}