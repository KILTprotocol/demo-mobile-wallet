package com.ethernom.android.etherapi

import android.annotation.SuppressLint
import android.content.Context
import android.content.Intent
import android.util.Log
import com.ethernom.android.etherapi.Utils.ByteListToByteArray
import com.ethernom.android.etherapi.Utils.ByteToByteArray
import com.ethernom.android.etherapi.Utils.GetDelimitedString
import com.ethernom.android.etherapi.Utils.GetEndedString
import com.ethernom.android.etherapi.linkLayer.AdapterListener
import com.facebook.react.bridge.*
import com.facebook.react.modules.core.DeviceEventManagerModule.RCTDeviceEventEmitter
import org.bouncycastle.jce.provider.BouncyCastleProvider
import org.json.JSONArray
import org.json.JSONObject
import java.nio.ByteBuffer
import java.nio.charset.Charset
import java.security.Security
import java.util.*

internal class EtherAPIManager(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext), AdapterListener {
    @SuppressLint("UseSparseArrays")
    private val etherApiInstances = HashMap<Int, EtherAPI>()
    private val _context: Context
    val reactContext: ReactApplicationContext


    //adb logcat -s ReactNative:V, ReactNativeJS:V, EtherAPIManager:V
    override fun getName(): String {
        return "EtherAPIManager"
    }

    fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { //Log.d(TAG, "onActivityResult");
    }

    // etherapi methods proper
    @ReactMethod
    fun _InitAPI(adapterConnectionString: String, servicePort: Int, secsTimeout: Int, allowDuplicates: Boolean, stopScanOnWrite: Boolean, callback: Callback) { //Log.d(TAG,"init api");
        val _etherAPI = EtherAPI.CreateInstance(adapterConnectionString, servicePort.toByte(), secsTimeout.toLong(), allowDuplicates, stopScanOnWrite,this, _context)
        etherApiInstances.put(instanceCount++, _etherAPI)

        //Log.d(TAG,"etherinst: " + Integer.toString(_etherApi?.thisId));
        callback.invoke(EtherError.ETH_SUCCESS, instanceCount - 1)
    }

    @ReactMethod
    fun _InitDFUAPI(adapterConnectionString: String, UUID: String?, secsTimeout: Int, allowDuplicates: Boolean, stopScanOnWrite: Boolean, callback: Callback) { //Log.d(TAG,"init DFU api");
        val _etherAPI = EtherAPI.CreateDFUInstance(adapterConnectionString, UUID!!, secsTimeout.toLong(), allowDuplicates, stopScanOnWrite,this, _context)
        etherApiInstances.put(instanceCount++, _etherAPI)

        //Log.d(TAG,"etherinst: " + Integer.toString(_etherApi?.thisId));
        callback.invoke(EtherError.ETH_SUCCESS, instanceCount - 1)
    }

    @ReactMethod
    fun _Select(instanceHandle: Int, deviceID: String, deviceName: String, callback: Callback) {
        val _etherApi = etherApiInstances[instanceHandle]
        //Log.d(TAG,"etherinst: " + Integer.toString(_etherApi?.thisId));

        val ci = CardInfo(deviceName, deviceID,"")
        _etherApi?.Select(ci, object : SelectListener {
            override fun onSelectSuccess(resultCode: Int) { //Log.d(TAG,"_OpenCard success");
                callback.invoke(resultCode)
            }

            override fun onSelectFail(resultCode: Int, hwSpecificError: Int) {
                callback.invoke(resultCode)
            }
            override fun onDisconnect(resultCode: Int, hwSpecificError: Int) {
                callback.invoke(resultCode)
            }
        })
    }

    private fun GetEthernomTypeValue(jObj: JSONObject, encoding: Int): List<Byte>? {
        try {
            when (encoding) {
                ETH_STRING_AS_UNICODE -> {
                    val value = jObj.getString("value")
                    return GetDelimitedString(value)
                }
                ETH_STRING_AS_ASUTF8 -> {
                    val value = jObj.getString("value")
                    return GetDelimitedString(value)
                }
                ETH_INT_AS_BYTE -> {
                    val value = jObj.getInt("value")
                    val cc: MutableList<Byte> = ArrayList()

                    cc.add(value.toByte())
                    return cc
                }
                ETH_INT_AS_2BYTE -> {
                    val value = jObj.getInt("value")
                    val cc: MutableList<Byte> = ArrayList()

                    cc.add((value and 0xFF).toByte())
                    cc.add((value shr 8 and 0xFF).toByte())

                    return cc
                }
                ETH_INT_AS_4BYTE -> {
                    val value = jObj.getInt("value")
                    val cc: MutableList<Byte> = ArrayList()

                    cc.add((value and 0xFF).toByte())
                    cc.add((value shr 8 and 0xFF).toByte())
                    cc.add((value shr 16 and 0xFF).toByte())
                    cc.add((value shr 24 and 0xFF).toByte())

                    return cc
                }
                ETH_STRING_AS_HEX -> {
                    val value = jObj.getString("value")
                    val cc: MutableList<Byte> = ArrayList()
                    val array = hexStringToByteArray(value)

                    for (i in array.indices) {
                        cc.add(array[i])
                    }

                    return cc
                }
                ETH_AS_ARRAY -> {
                    val array = jObj.getJSONArray("value")
                    val cc: MutableList<Byte> = ArrayList()

                    for (i in 0 until array.length()) {
                        cc.add(array.optInt(i).toByte())
                    }

                    return cc
                }
                else -> { //Log.d(TAG, "unknown encoding:" + Integer.toString(encoding));

                }
            }
        } catch (ex: Exception) {

        }

        return null
    }

    private fun AddToPayload(jObj: JSONArray, currentPayload: List<Byte>): List<Byte> {
        val payload: MutableList<Byte> = ArrayList()
        payload.addAll(currentPayload)

        try {
            for (i in 0 until jObj.length()) {
                val theObject = jObj.getJSONObject(i)
                val keys: Iterator<*> = theObject.keys()
                val sk = keys.next() as String
                val obj = theObject[sk]

                when (obj) {
                    is String -> {
                        val value = theObject.getString(sk)

                        //Log.d(TAG, "String value: " + value);
                        var s: List<Byte?> = ArrayList()
                        s = when {
                            keys.hasNext() -> {
                                GetDelimitedString(value)
                            }
                            else -> {
                                GetEndedString(value)
                            }
                        }

                        payload.addAll(s)
                    }
                    is Int -> {
                        val value = theObject.getInt(sk)
                        payload.add(value.toByte())

                        //Log.d(TAG,"Int value: "+Integer.toString(value));
                    }
                    else -> { // its a full field def
                        //  JSONObject jo = reader.getJSONObject(sk);
                        val jo = theObject.getJSONObject(sk)

                        // figure out if its a ethernome defined type
                        var xencoding = -1

                        try {
                            xencoding = jo.getInt("encoding")
                        } catch (ex: Exception) {

                        }

                        when {
                            xencoding != -1 -> { // an ethernom encoding struct
                                //Log.d(TAG,"ethernom type struct found");
                                val p = GetEthernomTypeValue(jo, xencoding)

                                if (p != null) {
                                    payload.addAll(p)
                                }
                            }
                            else -> { //Log.d(TAG,"json struct found");
                                val jsonArray = JSONArray()
                                jsonArray.put(theObject)

                                val p = AddToPayload(jsonArray, currentPayload)
                                payload.addAll(p)
                            }
                        }

                        //Log.d(TAG, jo.toString());
                    }
                }
            }
        } catch (ex: Exception) { //Log.d(TAG, ex.getMessage());

        }
        return payload
    }

    private fun parseToOutputJSON(payload: ByteArray, outputJSONDef: String): String {
        val jcc = JSONObject()
        var pp = 0

        try {
            val jarray = JSONArray(outputJSONDef)

            //def
            for (j in 0 until jarray.length()) {

                if (pp == payload.size) {
                    break
                }

                val def = jarray.getJSONObject(j)
                val keys: Iterator<*> = def.keys()
                val sk = keys.next() as String
                val etype = def.getInt(sk)

                when (etype) {
                    ETH_BYTE -> {
                        var `val` = payload[pp].toInt()

                        if (`val` < 0) {
                            `val` = `val` and 0xFF
                        }

                        pp += 1
                        jcc.put(sk, `val`)
                    }
                    ETH_2BYTE -> {
                        var `val`: Int = payload[pp + 1].toInt() and 0xFF shl 8 or (payload[pp].toInt() and 0xFF)

                        if (`val` < 0) {
                            `val` = `val` and 0xFFFF
                        }

                        pp += 2
                        jcc.put(sk, `val`)
                    }
                    ETH_4BYTE -> {
                        val buffer = ByteBuffer.allocate(8).put(byteArrayOf(0, 0, 0, 0, payload[pp + 3], payload[pp + 2], payload[pp + 1], payload[pp]))
                        buffer.position(0)

                        val lcc = buffer.long
                        pp += 4
                        jcc.put(sk, lcc)
                    }
                    ETH_UTF8STRING -> {
                        val bytes = ArrayList<Byte>()

                        while (payload[pp] != EtherTransportProtocol.DELIMITER.toByte() && payload[pp] != 0.toByte()) {
                            val b = payload[pp]
                            bytes.add(b)
                            pp += 1
                        }

                        pp += 1 // past delims

                        val data = ByteListToByteArray(bytes)
                        val s = String(data, Charset.forName("UTF-8"))
                        jcc.put(sk, s)
                    }
                    ETH_PAYLOAD -> {
                        val arr = JSONArray()

                        for (i in payload.indices) {
                            var `val` = payload[i].toInt()

                            if (`val` < 0) {
                                `val` = `val` and 0xFF
                            }

                            arr.put(`val`)
                        }

                        jcc.put(sk, arr)
                    }
                }
            }
        } catch (ex: Exception) { //Log.d(TAG,ex.getMessage());

        }

        return jcc.toString()
    }

    @ReactMethod
    fun _WriteJSON(instanceHandle: Int?, json: String?, outPutJSONDef: String, callback: Callback) {
        val _etherApi = etherApiInstances[instanceHandle]

        //Log.d(TAG,"etherinst writeJSON: " + Integer.toString(_etherApi?.thisId));
        try {
            val jobj = JSONArray(json)
            val payload: List<Byte> = ArrayList()
            val finalPayload = AddToPayload(jobj, payload)
            val bytes = finalPayload.toTypedArray()
            val data = ByteToByteArray(bytes)

            _etherApi?.Write(data, object : ReadListener {
                override fun onReadSuccess(resultCode: Int, payload: ByteArray?) { //Log.d(TAG,"on read success send to react");
                    _etherApi.ClearReadListener()
                    val retJSON = payload?.let { parseToOutputJSON(it, outPutJSONDef) }
                    callback.invoke(resultCode, retJSON)
                }

                override fun onReadFail(resultCode: Int, hwSpecificError: Int) {
                    _etherApi.ClearReadListener()
                    callback.invoke(resultCode, hwSpecificError)
                }
            })
        } catch (ex: Exception) { //Log.d(TAG, ex.getMessage());

        }
    }

    @ReactMethod
    fun _WriteJSON_DL(instanceHandle: Int?, json: String?, outPutJSONDef: String, callback: Callback) {
        val _etherApi = etherApiInstances[instanceHandle]

        //Log.d(TAG,"etherinst writeJSON_DL: " + Integer.toString(_etherApi?.thisId));
        try {
            val jobj = JSONArray(json)
            val payload: List<Byte> = ArrayList()
            val finalPayload = AddToPayload(jobj, payload)
            val bytes = finalPayload.toTypedArray()
            val data = ByteToByteArray(bytes)

            _etherApi?.Write_DL(data, object : ReadListener {
                override fun onReadSuccess(resultCode: Int, payload: ByteArray?) { //Log.d(TAG,"on read success send to react");
                    _etherApi.ClearReadListener()
                    val retJSON = payload?.let { parseToOutputJSON(it, outPutJSONDef) }
                    callback.invoke(resultCode, retJSON)
                }

                override fun onReadFail(resultCode: Int, hwSpecificError: Int) {
                    _etherApi.ClearReadListener()
                    callback.invoke(resultCode, hwSpecificError)
                }
            })
        } catch(ex: Exception) { //Log.d(TAG, ex.getMessage());

        }
    }
    @ReactMethod
    fun _WriteJSON_Encrypted(instanceHandle: Int?, encrypt: Boolean, json: String?, outPutJSONDef: String, callback: Callback) {
        val _etherApi = etherApiInstances[instanceHandle]
        try {
            val jobj = JSONArray(json)
            val payload: List<Byte> = ArrayList()
            val finalPayload = AddToPayload(jobj, payload)
            val bytes = finalPayload.toTypedArray()
            val data = ByteToByteArray(bytes)

            _etherApi?.WriteEncrypted(data, encrypt, object : ReadListener {

                override fun onReadSuccess(resultCode: Int, payload: ByteArray?) { //Log.d(TAG,"on read success send to react");
                    _etherApi.ClearReadListener()
                    val retJSON = payload?.let { parseToOutputJSON(it, outPutJSONDef) }
                    callback.invoke(resultCode, retJSON)
                }

                override fun onReadFail(resultCode: Int, hwSpecificError: Int) {
                    _etherApi.ClearReadListener()
                    callback.invoke(resultCode, hwSpecificError)
                }
            });
        } catch(e : Exception) {

        }
    }

    @ReactMethod
    fun _WriteJSON_Generic(instanceHandle: Int?, json: String?, outPutJSONDef: String, callback: Callback) {
        val _etherApi = etherApiInstances[instanceHandle]
        try {
            val jobj = JSONArray(json)
            val payload: List<Byte> = ArrayList()
            val finalPayload = AddToPayload(jobj, payload)
            val bytes = finalPayload.toTypedArray()
            val data = ByteToByteArray(bytes)

            _etherApi?.Write_Generic(data, object : ReadListener {
                override fun onReadSuccess(resultCode: Int, payload: ByteArray?) { //Log.d(TAG,"on read success send to react");
                    _etherApi.ClearReadListener()
                    val retJSON = payload?.let { parseToOutputJSON(it, outPutJSONDef) }
                    callback.invoke(resultCode, retJSON)
                }

                override fun onReadFail(resultCode: Int, hwSpecificError: Int) {
                    _etherApi.ClearReadListener()
                    callback.invoke(resultCode, hwSpecificError)
                }
            })
        } catch (ex: Exception) { //Log.d(TAG, ex.getMessage());

        }
    }

    @ReactMethod
    fun _CardClose(instanceHandle: Int?, callback: Callback?) {
        val _etherApi = etherApiInstances[instanceHandle]

        //Log.d(TAG,"etherinst _CardClose: " + Integer.toString(_etherApi?.thisId));
        _etherApi?.CardClose(object : CardCloseListener {
            override fun onCardCloseSuccess(resultCode: Int) {
                callback?.invoke(resultCode)
            }

            override fun onCardCloseFail(resultCode: Int, hwSpecificError: Int) {}
        })
    }

    @ReactMethod
    fun _onCardDisconnected(instanceHandle: Int?, callbackEventName: String?) {
        val _etherApi = etherApiInstances[instanceHandle]

        //Log.d(TAG,"etherinst _onCardDisconnected: " + Integer.toString(_etherApi?.thisId));
        _etherApi?.onCardDisconnected(object : ConnectionListener {
            override fun onConnectionDropped(resultCode: Int) {
                val params = Arguments.createMap()
                params.putInt("resultCode", resultCode)

                // Get EventEmitter from context and send event thanks to it
                reactContext
                        .getJSModule(RCTDeviceEventEmitter::class.java)
                        .emit(callbackEventName!!, params)
            }
        })
    }

    @ReactMethod
    fun _SubscribeToUnsolictedEvents(instanceHandle: Int?, outPutJSONDef: String, callbackEventName: String?) {
        val _etherApi = etherApiInstances[instanceHandle]

        //Log.d(TAG,"etherinst __SubscribeToUnsolictedEvents: " + Integer.toString(_etherApi?.thisId));
        _etherApi?.SubscribeToUnsolictedEvents(object : UnSolicitedEventListener {
            override fun onUnsolicitedEvent(resultCode: Int, payload: ByteArray?) {
                val retJSON = payload?.let { parseToOutputJSON(it, outPutJSONDef) }
                val params = Arguments.createMap()

                // Put data to map
                params.putInt("resultCode", resultCode)
                params.putString("msgJSON", retJSON)

                // Get EventEmitter from context and send event thanks to it
                reactContext
                        .getJSModule(RCTDeviceEventEmitter::class.java)
                        .emit(callbackEventName!!, params)
            }
        })
    }

    @ReactMethod
    fun _UnSubscribeToUnsolictedEvents(instanceHandle: Int?, callbackEventName: String?) { // dont really need event but passed for symmetry and when we add multpile event listeners
        val _etherApi = etherApiInstances[instanceHandle]

        //Log.d(TAG,"__SubscribeToUnsolictedEvents");
        // simply unhook the callback, React unhooks it on the js thread side
        _etherApi?.ClearUnsolicitedEventListener()
    }

    @ReactMethod
    fun _StopDiscovery(instanceHandle: Int?) {
        val _etherApi = etherApiInstances[instanceHandle]

        //Log.d(TAG,"etherinst _StopDiscovery: " + Integer.toString(_etherApi?.thisId));
        _etherApi?.StopDiscovery()
    }

    @ReactMethod
    fun _DiscoverDevices(instanceHandle: Int?, callbackEventName: String?) {
        val _etherApi = etherApiInstances[instanceHandle]

        //Log.d(TAG,"etherinst _Discover: " + Integer.toString(_etherApi?.thisId));
        _etherApi?.DiscoverDevices(object : DiscoverServiceListener {
            override fun onServiceDiscover(resultCode: Int, peripheralID: String, deviceName: String, dSerialNum: String) {
                val params = Arguments.createMap()
                // Put data to map
                params.putInt("resultCode", resultCode)
                params.putString("peripheralID", peripheralID)
                params.putString("deviceName", deviceName)
                params.putString("dSerialNum", dSerialNum)

                // Get EventEmitter from context and send event thanks to it
                reactContext
                        .getJSModule(RCTDeviceEventEmitter::class.java)
                        .emit(callbackEventName!!, params)
                //callback.invoke(resultCode, deviceID, deviceName);
            }

            override fun onServiceDiscoverFail(resultCode: Int, hwSpecificError: Int) {}
            override fun onServiceDiscoverEnd(resultCode: Int) {}
        })
    }
    @ReactMethod
    fun _DoAppKeyExchange(instanceHandle: Int, pin: String, callback: Callback){
        val _etherApi = etherApiInstances[instanceHandle]
        _etherApi?.onSecureConnection(object : EncConnectionListener {
            override fun onSecureConnectionEstablished(resultCode: Int) {
                callback?.invoke(resultCode)
            }
        })
        _etherApi?.DoKeyExchange(pin);
    }

    companion object {
        const val TAG = "EtherAPIManager"
        private var instanceCount = 0
        private const val ETH_STRING_AS_UNICODE = 0x01
        private const val ETH_STRING_AS_HEX = 0x02
        private const val ETH_STRING_AS_ASUTF8 = 0x03
        private const val ETH_INT_AS_BYTE = 0x04
        private const val ETH_INT_AS_2BYTE = 0x05
        private const val ETH_INT_AS_4BYTE = 0x06
        private const val ETH_AS_ARRAY = 0x07
        private const val ETH_UNICODESTRING = 0x11
        private const val ETH_UTF8STRING = 0x12
        private const val ETH_BYTE = 0x13
        private const val ETH_2BYTE = 0x14
        private const val ETH_PAYLOAD = 0x15
        private const val ETH_4BYTE = 0x16

        private fun hexStringToByteArray(s: String): ByteArray {
            val len = s.length
            val data = ByteArray(len / 2)
            var i = 0

            while (i < len) {
                data[i / 2] = ((Character.digit(s[i], 16) shl 4)
                        + Character.digit(s[i + 1], 16)).toByte()
                i += 2
            }

            return data
        }
    }

    init {
        _context = reactContext
        this.reactContext = reactContext
        Security.removeProvider("BC");
        Security.insertProviderAt(BouncyCastleProvider(), 1);

        //Log.d(TAG, "etherapimanager created");
    }

    override fun onAdapterOpenSuccess(resultCode: Int) {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
    override  fun onAdapterOpenFail(resultCode: Int, hwSpecificError: Int) {
        TODO("not implemented") //To change body of created functions use File | Settings | File Templates.
    }
}