package com.ethernom.android.etherapi

import android.content.Context
import android.util.Log
import com.ethernom.android.etherapi.Extentions.hexa
import com.ethernom.android.etherapi.linkLayer.*
import org.json.JSONArray
import org.json.JSONObject
import java.nio.ByteBuffer
import kotlin.experimental.and

class EtherAPI: DiscoverServiceListener, CardListener, AdapterListener, ConnectionListener, EncConnectionListener {
    companion object {
        var instanceCount: Int = 0

        public fun CreateInstance(adapterConnectionString: String, App_ID: Byte, secsTimeout: Long, allowDuplicates: Boolean, stopScanOnWrite: Boolean, adapterListener: AdapterListener, context: Context) : EtherAPI {
            val etherApi = EtherAPI()
            etherApi.instanceID = instanceCount
            val cc = instanceCount
            instanceCount += 1

            etherApi._adapterListener = adapterListener
            etherApi._appId = App_ID
            if ((adapterConnectionString.startsWith("BLE"))) {
                etherApi._adapter = EtherBTAdapter()
                etherApi._adapter!!.Init(
                    servicePort = App_ID,
                    secsTimeout = secsTimeout,
                    allowDuplicates = allowDuplicates,
                    stopScanOnWrite = stopScanOnWrite,
                    context = context
                )

                etherApi.transport = EtherTransportProtocol(
                    servicePort = App_ID,
                    interfaceKind = etherApi!!._adapter!!.GetInterface(),
                    messageProtocol = TMessageProtocol.APP
                )

                etherApi.SetupCardListeners(etherApi._adapter!!)
            }
            return etherApi
        }

        public fun CreateDFUInstance( adapterConnectionString: String, App_ID: String, secsTimeout: Long, allowDuplicates: Boolean, stopScanOnWrite: Boolean, adapterListener: AdapterListener, context : Context) : EtherAPI {
            val etherApi = EtherAPI()
            etherApi.instanceID = instanceCount
            val cc = instanceCount
            instanceCount += 1

            etherApi._adapterListener = adapterListener
            if ((adapterConnectionString.startsWith("BLE"))) {
                etherApi._adapter = EtherBTAdapter()
                (etherApi._adapter as EtherBTAdapter).Init_DFU(
                    UUID = App_ID,
                    secsTimeout = secsTimeout,
                    allowDuplicates = allowDuplicates,
                    stopScanOnWrite = stopScanOnWrite,
                    context = context
                )

                etherApi.transport = EtherTransportProtocol(
                    servicePort = 0,
                    interfaceKind = etherApi._adapter!!.GetInterface(),
                    messageProtocol = TMessageProtocol.APP
                )

                etherApi.SetupCardListeners(etherApi._adapter!!)
            }
            return etherApi
        }
    }

    var _adapter: EtherCommAdapter? = null
    var transport: EtherTransportProtocol = EtherTransportProtocol(
        servicePort = 0,
        interfaceKind = TInterface.BLE,
        messageProtocol = TMessageProtocol.APP
    )
    var openServiceCmd: Byte = (-1).toByte()
    var instanceID: Int = 0
    var _selectListener: SelectListener? = null
    var _readListener: ReadListener? = null
    var _discoverServiceListener: DiscoverServiceListener? = null
    var _adapterListener: AdapterListener? = null
    var _cardClosedListener: CardCloseListener? = null
    var _unSolicitedEventListener: UnSolicitedEventListener? = null
    var _connectionListener: ConnectionListener? = null
    var _encConnectionListener: EncConnectionListener? = null
    var _scanSecsTimeout: Long = 30000
    var _scanAllowDuplicates: Boolean = false
    var _scanStopScanOnWrite: Boolean = false
    var _secureSessionManger: FrameworkSecureSession? = null
    var _appId: Byte = 0

    constructor() : super() {

    }

    fun hasReadListener() : Boolean {
        if ((_readListener != null)) {
            return true
        }
        return false
    }

    fun GetDelimitedString(data: String) : List<Byte> {
        // Construct payload as series of delimited strings
        var payload = arrayListOf<Byte>()

        if (data.toByteArray(Charsets.UTF_8).isEmpty()) {
            payload.add(0)
        } else {
            payload.addAll(data.toByteArray(Charsets.UTF_8).toList())
            payload.add(EtherTransportProtocol.DELIMITER)
        }

        return payload
    }

    fun GetEndedString(data: String) : List<Byte> {
        // Construct payload as series of delimited strings
        var payload = arrayListOf<Byte>()

        if (data.toByteArray(Charsets.UTF_8).isEmpty()) {
            payload.add(0)
        } else {
            payload.addAll(data.toByteArray(Charsets.UTF_8).toList())
            payload.add(0)
        }

        return payload
    }

    fun SetupCardListeners(adapter: EtherCommAdapter) {
        _adapter?.SetDiscoverServiceEventListener(listener = this)
        _adapter?.SetCardEventListener(listener = this)
        _adapter?.SetAdapterEventListener(listener = this)
    }

    override fun onAdapterOpenSuccess(resultCode: Int) {
        _adapterListener?.onAdapterOpenSuccess(resultCode = resultCode)
    }

    override fun onAdapterOpenFail(resultCode: Int, hwSpecificError: Int) {
        _adapterListener?.onAdapterOpenFail(resultCode = resultCode, hwSpecificError = hwSpecificError)
    }

    fun ClearUnsolicitedEventListener() {
        this._unSolicitedEventListener = null
    }

    fun ClearReadListener() {
        this._readListener = null
    }

    fun StopDiscovery() {
        this._adapter?.StopDiscovery()
    }

    fun CardClose(closeListener: CardCloseListener) {
        _cardClosedListener = closeListener
        _discoverServiceListener = null
        _adapter?.CardClose()
    }

    fun SubscribeToUnsolictedEvents(unSolicitedEventListener: UnSolicitedEventListener) {
        _readListener = null
        _unSolicitedEventListener = unSolicitedEventListener
        ClearReadListener()
    }

    fun DiscoverDevices(discoverServiceListener: DiscoverServiceListener) {
        _discoverServiceListener = discoverServiceListener
        _adapter?.Discover()
    }

    override fun onConnectionDropped(resultCode: Int) {
        if ((_connectionListener != null)) {
            _connectionListener?.onConnectionDropped(resultCode = resultCode)
        }
    }

    override fun onSecureConnectionEstablished(resultCode: Int) {
        if ((_encConnectionListener != null)) {
            _encConnectionListener?.onSecureConnectionEstablished(resultCode = resultCode)
        }
    }

    fun onSecureConnection(encConnectionListener: EncConnectionListener) {
        _encConnectionListener = encConnectionListener
    }

    fun DoKeyExchange(pin: String) {
        // kick off dh key exchange
        if (_secureSessionManger == null) {
            val btClient = _adapter as EtherBTAdapter

            _secureSessionManger = FrameworkSecureSession(
                bleClient = btClient,
                secureAppSessionEstablished = {
                    secureAppSessionEstablished(it)
                },
                appMessageReceived = {transportCmdByte, value ->
                    handle_command(transportCmdByte, value)
                }
            )
        }

        _secureSessionManger?.DoKeyExchange(pin = pin, cmd = _appId)
    }

    fun handle_command(transportCmdByte: Byte, value: List<Byte>) {
        //println(value);
        if ((transportCmdByte == PSD_MGR_PORT)) {
            println("app message received")
        } else if ((transportCmdByte == GENERIC_PORT)) {
            println("unexpected generic port number received")
        }
    }

    fun secureAppSessionEstablished(result: EtherErrorValue) {
        if (_encConnectionListener != null) {
            _encConnectionListener?.onSecureConnectionEstablished(resultCode = result)
        }
    }

    // MARK: - onCardDisconnected
    fun onCardDisconnected(connectionListener: ConnectionListener) {
        _connectionListener = connectionListener
    }

    override fun onCardConnectionDropped(resultCode: Int) {
        if ((_connectionListener != null)) {
            _connectionListener?.onConnectionDropped(resultCode = resultCode)
        }
    }

    override fun onServiceDiscover(resultCode: Int, peripheralID: String, deviceName: String, dSerialNum: String) {
        _discoverServiceListener?.onServiceDiscover(resultCode = resultCode, peripheralID = peripheralID, deviceName = deviceName, dSerialNum = dSerialNum)
    }

    override fun onServiceDiscoverEnd(resultCode: Int) {
        _discoverServiceListener?.onServiceDiscoverEnd(resultCode = resultCode)
    }

    override fun onServiceDiscoverFail(resultCode: Int, hwSpecificError: Int) {
        _discoverServiceListener?.onServiceDiscoverFail(resultCode = resultCode, hwSpecificError = hwSpecificError)
    }

    fun Select(cardInfo: CardInfo, selectListener: SelectListener) {
        _selectListener = selectListener
        _adapter?.CardOpen(cardInfo = cardInfo)
    }

    fun Write(buffer: ByteArray, readListener: ReadListener) {
        // create a Transport layer packet
        _unSolicitedEventListener = null

        if ((_readListener != null)) {
            _readListener = null
        }
        _readListener = readListener
        val msg = transport.GetPayload(data = buffer!!.toList())
        _adapter!!.WriteToCard(buffer = msg.toByteArray());
    }

    fun Write_DL(buffer: ByteArray, readListener: ReadListener) { // create a Transport layer packet
        _unSolicitedEventListener = null

        if ((_readListener != null)) {
            _readListener = null
        }
        _readListener = readListener
        val msg: ByteArray = transport.GetPayload_DL(buffer)
        _adapter!!.WriteToCard(msg)
    }

      //DOWNLOADER TRANSPORT WRITE
    fun Write_Generic(buffer: ByteArray, readListener: ReadListener): Unit { // create a Transport layer packet
        _unSolicitedEventListener = null

        if ((_readListener != null)) {
          _readListener = null
        }
        _readListener = readListener
        val msg: List<Byte> = transport.GetPayload_Generic(buffer.toList())
        _adapter!!.WriteToCard(msg.toByteArray())
    }

    fun WriteEncrypted(buffer: ByteArray, doEncrypt: Boolean, readListener: ReadListener):Unit {
        // create a Transport layer packet
        if (_secureSessionManger == null) {
            val btClient = _adapter as EtherBTAdapter
            _secureSessionManger = FrameworkSecureSession(
                bleClient = btClient,
                secureAppSessionEstablished = {
                    secureAppSessionEstablished(it)
                },
                appMessageReceived = {transportCmdByte, value ->
                    handle_command(transportCmdByte, value)
                }
            )
        }

        _unSolicitedEventListener = null

        if ((_readListener != null)) {
            _readListener = null
        }
        _readListener = readListener
        _secureSessionManger?.WriteDataToCardEncrypted(doEncrypt = doEncrypt, AppData = buffer)
    }

    // MARK: - CardEventListener
    override fun onCardOpenSuccess(resultCode: Int) {
        // the card was opened
        // inform the app side
        _selectListener?.onSelectSuccess(resultCode = resultCode)
    }

    override fun onCardOpenFail(resultCode: Int, hwSpecificError: Int) {
        _selectListener?.onSelectFail(resultCode = EtherError.ERR_ETH_SELECT_FAILED, hwSpecificError = resultCode)
    }

    override fun onCardClosedSucess(resultCode: Int) {
        _cardClosedListener?.onCardCloseSuccess(resultCode = resultCode)
    }

    override fun onCardClosedByCard(resultCode: Int) {
        _selectListener?.onDisconnect(resultCode = EtherError.ERR_ETH_DISCONNECTED, hwSpecificError = resultCode)
    }

    fun onCardClosedFail(resultCode: Int, hwSpecificError: Int) {
        _selectListener?.onDisconnect(resultCode = EtherError.ERR_ETH_DISCONNECTED, hwSpecificError = resultCode)
    }

    override fun onWriteToCardSuccess(resultCode: Int) {

    }

    //println("Write to card succeeded")
    override fun onWriteToCardFail(resultCode: Int, hwSpecificError: Int) {

    }

    //println("Write to card failed")
    override fun onReadFromCardFail(resultCode: Int, hwSpecificError: Int) {
        //println("read from card failed")

        if (_readListener != null) {
            // only deliver the payload
            _readListener?.onReadSuccess(resultCode = resultCode, payload = listOf(0.toByte()).toByteArray())
        }
    }

    override fun onReadFromCardSuccess(resultCode: Int, buffer: ByteArray) {
        // we are coming in here with in theory a full transport layer buffer
        //println("Read from card success")
        // in the old code we check  buffer[1] for this also
        if ((buffer[0] == transport.GetServicePort() || buffer[0] == transport.GetDLServicePort() || buffer[0] == transport.GetGenericServicePort())) {
            if (_readListener != null) {
                // only deliver the payload
                val payload = try { transport.GetApplicationData(data = buffer) } catch (e: Throwable) { null }

                if (payload != null) {
                    _readListener?.onReadSuccess(resultCode = resultCode, payload = payload)
                }
            } else if (_unSolicitedEventListener != null) {
                val payload = try { transport.GetApplicationData(data = buffer) } catch (e: Throwable) { null }

                if (payload != null) {
                    _unSolicitedEventListener?.onUnsolicitedEvent(resultCode = resultCode, payload = payload)
                }
            }
        }
    }
}
