package com.ethernom.android.etherapi

import android.os.Handler
import android.os.Looper
import com.ethernom.android.etherapi.Crypto.*
import com.ethernom.android.etherapi.Extentions.Helpers.ParseEncryptedHeader
import com.ethernom.android.etherapi.Extentions.hexa
// fhc import com.ethernom.android.etherapi.linkLayer.EthBLEClient
import com.ethernom.android.etherapi.linkLayer.EtherBTAdapter
import kotlin.experimental.and
import org.json.JSONArray
import org.json.JSONObject
import android.os.Bundle
import java.util.*


//host to card
// this class does the various security and sessions messages necessary to creata secure live connection to an application in the card
class EtherSecureSession {
    var _ecdh = EtherECDH()
    var _aes_eax = Ether_AESEAX()

    var _cardConnectionEstablished: (EtherErrorValue) -> Unit?  // this is for the link/BLE connection
    var _secureCardSessionEstablished: (EtherErrorValue) -> Unit?
    var _appLaunched: (EtherErrorValue) -> Unit?
    var _secureAppSessionEstablished: (EtherErrorValue) -> Unit
    var _appMessageReceived: (Byte, List<Byte>) -> Unit

    var _host_name = String()

    var _pin: String = ""
    var _bleClient: EtherBTAdapter? = null
    val BLEClient: EtherBTAdapter
        get() {
            return _bleClient!!
        }

    // callbacks recieve EtherError codes
    constructor(
            string_id: String,
            string_name: String,
            cardConnectionEstablished: (result: Int) -> Unit,
            secureCardSessionEstablished: (EtherErrorValue) -> Unit,
            appLaunched: (EtherErrorValue) -> Unit,
            secureAppSessionEstablished: (EtherErrorValue) -> Unit,
            cardDisconnected: (EtherErrorValue) -> Unit,
            appMessageReceived: (Byte, List<Byte>) -> Unit
    ) {
        _cardConnectionEstablished = cardConnectionEstablished  // this is for the link/BLE connection
        _secureCardSessionEstablished = secureCardSessionEstablished
        _appLaunched = appLaunched
        _secureAppSessionEstablished = secureAppSessionEstablished
        _appMessageReceived = appMessageReceived

  /* fhc      _bleClient = EthBLEClient()

        // we use all callbacks so no need for command handler
        _bleClient?.initEthBLE(
                string_id = string_id,
                string_name = string_name,
                aex_eax = _aes_eax,
                cardDisconnected = cardDisconnected,
                peripheralConnectedHandler = cardConnectionEstablished,
                readSuccessHandler = {items ->
                    dataPacketReceived(items)
                }
        )*/
    }

    fun dataPacketReceived(value: List<Byte>) {
        if ((value[2] and (FLAG_CONTAIN_ENCRYPTION_HDR).toByte()) > 0) {
            // decrypt
            // send in just the transport payload (encheader + app payload
            val (encHeader, transportPayload, appPayload) = ParseEncryptedHeader(value.toByteArray())

            println(encHeader.hexa())
            println(transportPayload.hexa())
            println(appPayload.hexa())

            val DecryptedPacket = _aes_eax.DecryptByteArray(
                    encHeader = (encHeader),
                    encAppData = (appPayload)
            )
            val vanillaPacket = transportPayload + DecryptedPacket!!

            _appMessageReceived(transportPayload[0], vanillaPacket.toList())
        } else {
            _appMessageReceived(value[0], value)
        }
    }

    fun DoStartCardAuthentication(appID: Byte) {
        var payload = arrayListOf<Byte>()
        payload.add(CM_INIT_APP_PERM)
        payload.add(INT8NULL)
        payload.add(1)
        payload.add(INT8NULL)

        //     payload.add(PSD_MGR_ID);
        payload.add(appID)
/* fhc
        _bleClient!!.WriteByteArrayToCard_Generic(
                data = payload,
                writeCallback = { tvalue  ->
                    val value = tvalue

                    when {
                        value[EtherTransportProtocol.ETH_BLE_HEADER_SIZE] != CM_AUTHENTICATE -> {
                            println("Bad DH sequence from card")
                        }
                        else -> {
                            //    println(value);
                            var challenge = arrayListOf<Byte>()
                            var count = 0

                            for (num in value) {
                                if ((count > 11)) {
                                    challenge.add(num)
                                }

                                count += 1
                            }

                            Thread(Runnable {
                                this.generate_auth_rsp(challenge.toByteArray())
                            }).start()
                        }
                    }
                }
        )*/
    }

    //************  CM_INIT_APP_PERM answers from card and we come here to answer the challenge the car sends using our keys from server ***********************/
    //************  if the card answers with CM_ERR_SUCCESS, we callback the main view controlle which call MakeLaunchAppRequest below   ***********************/
    //************  we send in the clear and with no encryption header, sent to AO manager on card   ***********************/
    fun generate_auth_rsp(challenge: ByteArray) {
        println("challenge")
        println(challenge.hexa())
  // fhc      println(_bleClient!!.RegisteredSerialNumber)

  //      val keychain = Keychain(service = _bleClient!!.RegisteredSerialNumber, accessGroup = "group.com.ethernom.password.manager.mobile")
    //    val value = try { keychain.get(_bleClient!!.RegisteredSerialNumber) } catch (e: Throwable) { null }
        val value = "234234234"
        if ((value != null)) {
            val string_value = value!!
            val json_data = JSONObject(string_value)
//            val json_data = string_value.toJSON() as? Map<String, Any>
            val pubKey = json_data!!["pubkey"] as String
            val privKey = json_data!!["pkey"] as String
            val responseBytes = _ecdh.generate_auth_rsp(challenge = challenge, pubKey = pubKey, privKey = privKey)
  /* fhc          _bleClient!!.WriteByteArrayToCard_Generic(data = responseBytes!!, writeCallback = { tvalue  ->
                val value = tvalue
                println(CM_RSP)
                println(value[EtherTransportProtocol.ETH_BLE_HEADER_SIZE])
                println(value[12])
                when ((value[EtherTransportProtocol.ETH_BLE_HEADER_SIZE])) {
                    CM_RSP -> {
                        if ((value[12] == CM_ERR_SUCCESS)) {
                            println("Authenticate success!")
                            // we have established a card session,
                            this._secureCardSessionEstablished(EtherError.ETH_SUCCESS)
                        } else //                     self.readyHandler?(); // calls back to main page which sends a launchs
                        {
                            println("Auth fails")
                            this._bleClient?.cancelRequest()
                            this._secureCardSessionEstablished(EtherError.ETH_CARD_AUTH_FAIL)
                        }
                    }
                    else ->{
                        println("Invalid command")
                        this._bleClient?.cancelRequest()
                        this._secureCardSessionEstablished(EtherError.ETH_FAIL)
                    }
                }
            })*/
        }
    }

    //************  REQUEST APP LAUNCH AND IF IT SUCCEEDS, INIT PWD MANAGER BELOW, sent to AO manager on card, cleartext ***********************/
    fun RequestAppLaunch(host_name: String, appID: Byte) {
        val payload = arrayListOf<Byte>()
        payload.add(CM_LAUNCH_APP)
        payload.add(INT8NULL)
        payload.add(1)
        payload.add(INT8NULL)
        //payload.add(PSD_MGR_PORT);
        payload.add(appID)
/* fhc
        _host_name = host_name
        _bleClient?.WriteByteArrayToCard_Generic(data = payload, writeCallback = { tvalue  ->
            val value = tvalue
            if ((value[12] == CM_ERR_SUCCESS)) {
                Thread(Runnable {
                    if ((this._bleClient?.AutoReconnect == false && this._bleClient?.CancelRequest == false)) {
                        this._appLaunched(EtherError.ETH_SUCCESS)
                    }
                }).start()
            } else
            {
                this._bleClient?.CancelRequest = false
                this._bleClient?.StopScan()
            }
        })*/
    }

    //************  INIT PWD MANAGER, IF IT SUCCEEDS START KEY EXCHANGE FOR AEAD, sent WITH AN EMPTY ENCRYPTION HEADER, in the clear to pwd manager itself ***********************/
    fun requestPwdMgrInit(pin: String) {
        _pin = pin

        println("RequestPWdMgrInit")

        val encHeader = EtherEncHeader(
                cmd = APP_H2C_MSG.toByte(),
                status = 0,
                length = TRANSPORT_PLUS_ENC_HEADER_SIZE.toInt(),
                sequence = 0
        )
/* fhc
        this._bleClient?.WriteByteArrayToCard(
                cmd = H2C_RQST_INIT,
                data = listOf(_host_name, "000000"),
                encHeader = encHeader,
                writeCallback = { tvalue  ->
                    val value = tvalue

                    println(CM_RSP)
                    println(value[EtherTransportProtocol.ETH_BLE_HEADER_SIZE])
                    println(value[12])

                    this.doKeyExchange()
                }
        )*/
    }

    //************  GENERATE A RANDOM KEYPAIR AND SEND THE PUBLIC KEY TO CARD, CARD ACKS BACK WITH ITS OWN PUBLIC KEY FOR AEX_EAX ENCRYPTION ***********************/
    //************  GenerateSessionKeyFromSecret HANDLES THE HEAVY LIFTING, THEN WE NEXT START ENCRYPTION WITH CARD ***********************/
    //************  SENT IN THE CLEAR WITH ENCRYPTION HEADER AND PUBLIC KEY FROM HOST ***********************/
    fun doKeyExchange() {
        _aes_eax.GenerateKeyPair()

        var payload = ByteArray(0)
        payload += _aes_eax.GetPublicHostKey()

        val encHeader = EtherEncHeader(
                cmd = APP_H2C_KEY_EXCHANGE.toByte(),
                status = 0,
                length = TRANSPORT_PLUS_ENC_HEADER_SIZE.toInt(),
                sequence = _aes_eax.GetNextSequence()
        )

        this._bleClient?.WriteToCardEnc(
                data = _aes_eax.GetPublicHostKey(),
                encHeader = encHeader,
                writeCallback = { tvalue  ->
                    val runnable = Runnable() {
                        val (encHeader, _, appPayload) = ParseEncryptedHeader(tvalue)

                        if ((encHeader[0] == APP_C2H_KEY_EXCHANGE.toByte())) {
                            println("public key from card set")

                            this._aes_eax.SetCardPublicKey(appPayload)
                            this._aes_eax.GenerateSessionKeyFromSecret(this._pin)
                            this.doStartEncryptionWithCard()
                        } else {
                            println("Invalid command")
                        }
                    }
                    val handler = Handler()
                    handler.post(runnable)
                }
        )
    }

    fun doStartEncryptionWithCard() {
        // generate a random sequence
        _aes_eax.InitializeRandomSequence()

        val encHeader = EtherEncHeader(
                cmd = APP_H2C_ENCRYPT_START.toByte(),
                status = 0,
                length = 0,
                sequence = _aes_eax.GetNextSequence()
        )
        val data = encHeader.GetHeaderBuffer()
        this._bleClient?.WriteDataToCardHasEncryption(data = data, writeCallback = { tvalue  ->
            val (encHeader, _, _) = ParseEncryptedHeader(payload = tvalue)

            when {
                encHeader[0] == APP_C2H_ENCRYPT_START.toByte() -> {
                    this._secureAppSessionEstablished(EtherError.ETH_SUCCESS)
                }
                else -> {
                    println("Invalid command")
                }
            }
        })
    }

    fun requestSuspendApp() {
        /* fhc
        if ((_bleClient!!.HasPeripheralConnection)) {
            if ((_bleClient?.AutoReconnect == false)) {
                _bleClient?.CancelRequest = true
            }

            val payload = arrayListOf<Byte>()
            payload.add(CM_SUSPEND_APP)
            payload.add(INT8NULL)
            payload.add(1)
            payload.add(INT8NULL)
            payload.add(INT8NULL)

            _bleClient?.WriteByteArrayToCard_Generic(payload)
        } else {
            _bleClient?.cancelRequest()
        }*/
    }

    //*******************WriteByteArrayToCard encrypted methods
    fun getBytePayload(data: ByteArray) : ByteArray {
        var payload = ByteArray(0)

        if (data.isEmpty()) {
            payload += 0.toByte()
        } else {
            payload += data
        }

        return payload
    }

    // fully encrypted
    fun WriteByteArrayToCardEncrypted(cmd: Byte, AppData: ByteArray) {
        println("encrypted array of data outbound")
/* fhc
        val apppacket = _bleClient?.composePayload(cmd = cmd, data = AppData)

        apppacket?.let {
            val epacket = _aes_eax.EncryptByteArray(apppacket.toByteArray())

            epacket?.let {
                _bleClient?.WriteByteArrayToCardEncrypted(
                        appPort = PSD_MGR_PORT,
                        EncHeaderAndByteArray = epacket.toList()
                )
            }
        }*/
    }

    fun WriteByteArrayToCardEncrypted(cmd: Byte, AppData: ByteArray, log: String? = null) {
        println("encrypted array of data outbound")

        var apppacket = ByteArray(0)
        apppacket += cmd
        apppacket += getBytePayload(AppData)

        // get the encrypted header prepended to the actual encrypted data
 /*       val epacket = _aes_eax.EncryptByteArray(apppacket)
        epacket?.let {
            _bleClient?.WriteByteArrayToCardEncrypted(
                    appPort = PSD_MGR_PORT,
                    EncHeaderAndByteArray = it
            )
        }*/
    }
}
