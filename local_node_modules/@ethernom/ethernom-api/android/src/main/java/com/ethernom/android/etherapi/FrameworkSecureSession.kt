package com.ethernom.android.etherapi

import android.os.Handler
import android.util.Log
import com.ethernom.android.etherapi.Crypto.*
import com.ethernom.android.etherapi.Extentions.Helpers.ParseEncryptedHeader
import com.ethernom.android.etherapi.Extentions.hexa
import com.ethernom.android.etherapi.linkLayer.EtherBTAdapter
import kotlin.experimental.and

//host to card
// this class does the various security and sessions messages necessary to creata secure live connection to an application in the card
class FrameworkSecureSession {
    var _ecdh = EtherECDH()
    var _aes_eax = Ether_AESEAX()

    var _secureAppSessionEstablished: (EtherErrorValue) -> Unit
    var _appMessageReceived: (Byte, List<Byte>) -> Unit

    var _host_name = String()
    var _pin: String = ""

    var _bleClient: EtherBTAdapter? = null
    val BLEClient: EtherBTAdapter get() {
        return _bleClient!!
    }

    // callbacks recieve EtherError codes
    constructor(bleClient: EtherBTAdapter, secureAppSessionEstablished: (EtherErrorValue) -> Unit, appMessageReceived: (Byte, List<Byte>) -> Unit) {
        _secureAppSessionEstablished = secureAppSessionEstablished
        _appMessageReceived = appMessageReceived
        _bleClient = bleClient
    }

    fun DoKeyExchange(pin: String, cmd: Byte) {
        _pin = pin
        _aes_eax.GenerateKeyPair()

        var payload = ByteArray(0)
        payload += _aes_eax.GetPublicHostKey()

        val encHeader = EtherEncHeader(
            cmd = APP_H2C_KEY_EXCHANGE.toByte(),
            status = 0,
            length = TRANSPORT_PLUS_ENC_HEADER_SIZE.toInt(),
            sequence = _aes_eax.GetNextSequence()
        )

        this._bleClient?.WriteToCardEnc(
            data = payload,
            encHeader = encHeader,
            writeCallback = { tvalue : ByteArray  ->
                val (encHeader, _, appPayload) = ParseEncryptedHeader(tvalue)

                if ((encHeader[0] == APP_C2H_KEY_EXCHANGE.toByte())) {
                    this._aes_eax.SetCardPublicKey(appPayload)
                    this._aes_eax.GenerateSessionKeyFromSecret(this._pin)
                    this.doStartEncryptionWithCard()
                } else {
                    Log.d("ETHERBTADAPTER", "Invalid command")
                }
            }
        )
    }

    fun doStartEncryptionWithCard() {
        // generate a random sequence
        _aes_eax.InitializeRandomSequence()

        val encHeader = EtherEncHeader(
            cmd = APP_H2C_ENCRYPT_START.toByte(),
            status = 0,
            length = 0,
            sequence = _aes_eax.GetNextSequence()
        )

        val data = encHeader.GetHeaderBuffer()
        this._bleClient?.WriteDataToCardHasEncryption(
            data = data,
            writeCallback = { tvalue : ByteArray ->
                val (encHeader, _, _) = ParseEncryptedHeader(payload = tvalue)

                when {
                    encHeader[0] == APP_C2H_ENCRYPT_START.toByte() -> {
                        this._secureAppSessionEstablished(EtherError.ETH_SUCCESS)
                    }
                    else -> {
                        Log.d("ETHERBTADAPTER", "Invalid command")
                    }
                }
            }
        )
    }

    //*******************WriteByteArrayToCard encrypted methods
    fun getBytePayload(data: ByteArray) :ByteArray {
        var payload =ByteArray(0)

        if (data.isEmpty()) {
            payload += 0.toByte()
        } else {
            payload += data
        }

        return payload
    }

    fun dataPacketReceived(value: ByteArray) {
        val (encHeader, transportPayload, appPayload) = ParseEncryptedHeader(value)
        var fullPacket = ByteArray(0)

        val b1 : Int = value[2].toInt() and  FLAG_CONTAIN_ENCRYPTION_HDR
        val b2 :Int  = encHeader[0].toInt() and APP_FLAG_ENCRYPT

        if ((b1 > 0) and (b2 > 0)) {
            val DecryptedPacket = _aes_eax.DecryptByteArray(
                encHeader = (encHeader),
                encAppData = (appPayload)
            )

            fullPacket += transportPayload
            DecryptedPacket?.let {
                fullPacket += it
            }
        } else {
            fullPacket +=  transportPayload
            fullPacket +=  appPayload
        }

        _bleClient?.on_card_read_success(fullPacket)
    }

    fun WriteDataToCardEncrypted(doEncrypt: Boolean, AppData: ByteArray) {
        var apppacket = ByteArray(0)
        apppacket += getBytePayload(data = AppData)

        // get the encrypted header prepended to the actual encrypted data
        val epacket = if (doEncrypt) {
            _aes_eax.EncryptByteArray(apppacket)
        } else {
            _aes_eax.EmptyEncryptionHeader(apppacket)
        }

        this._bleClient?.WriteDataToCardHasEncryption(
            data = epacket!!,
            writeCallback = { tvalue : ByteArray ->
                this.dataPacketReceived(tvalue)
            }
        )
    }
}
